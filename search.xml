<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactNative开发-Xcode 10.2 运行`run-ios`找不到 iPhone 模拟器]]></title>
    <url>%2F2019%2F03%2F25%2FReactNative%E5%BC%80%E5%8F%91-Xcode-10-2-%E8%BF%90%E8%A1%8C-%E6%89%BE%E4%B8%8D%E5%88%B0-iPhone-%E6%A8%A1%E6%8B%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[更新 Xcode 10.2 后运行 React Native 项目出现 Could not find iPhone 6 simulator 找不到 iPhone 模拟器 在项目中的~/node_modules/react-native/local-cli/runIOS/findMatchingSimulator.js的文件里 找到对应的文件,和对应的代码1234567if (!version.startsWith(&apos;iOS&apos;) &amp;&amp; !version.startsWith(&apos;tvOS&apos;)) &#123; continue;&#125;或者if (version.indexOf(&apos;iOS&apos;) !== 0) &#123; continue;&#125; 将iOS前面加上com.apple.CoreSimulator.SimRuntime 1234567if (!version.startsWith(&apos;com.apple.CoreSimulator.SimRuntime.iOS&apos;) &amp;&amp; !version.startsWith(&apos;com.apple.CoreSimulator.SimRuntime.tvOS&apos;)) &#123; continue;&#125;或if (version.indexOf(&apos;com.apple.CoreSimulator.SimRuntime.iOS&apos;) !== 0) &#123; continue;&#125;]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web学习-freeCodeCamp课程学习]]></title>
    <url>%2F2018%2F11%2F01%2FWeb%E5%AD%A6%E4%B9%A0-freeCodeCamp%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一、Responsive Web Design Certification(响应式网页设计认证)1. Basic HTML and HTML5(基本的HTML和HTML5)2. Basic CSS（基本CSS）3. Applied Visual Design（应用视觉设计） Create Visual Balance Using the text-align Property h4标记上的text-align属性将其设置为 centerp标记上的text-align属性将其设置为 justify 123456h4 &#123; text-align: center; &#125; p &#123; text-align: justify; &#125; Adjust the Width of an Element Using the width Property（使用width属性调整元素的宽度） 为fullCard类选择器，设置width属性为245px 1234567.fullCard &#123; width: 245px; border: 1px solid #ccc; border-radius: 5px; margin: 10px 5px; padding: 4px; &#125; Adjust the Height of an Element Using the height Property（使用height属性调整元素的高度） 将height属性添加到h4标记并将其设置为25px 1234h4 &#123; text-align: center; height: 25px; &#125; Use the strong Tag to Make Text Bold（使用strong标记使文字粗体） 在p标签内围绕”Stanford University”包裹一个strong标签。 1&lt;p&gt;Google was founded by Larry Page and Sergey Brin while they were Ph.D. students at &lt;strong&gt;Stanford University&lt;/strong&gt;.&lt;/p&gt; Use the u Tag to Underline Text（使用u标签为文本加下划线） 在”Ph.D. students”文本周围包裹u标签 1&lt;p&gt;Google was founded by Larry Page and Sergey Brin while they were &lt;u&gt;Ph.D. students&lt;/u&gt; at &lt;strong&gt;Stanford University&lt;/strong&gt;.&lt;/p&gt; Use the em Tag to Italicize Text（使用em标记来显示文本） em标签应该环绕p标签的内容 12345&lt;p&gt; &lt;em&gt; Google was founded by Larry Page and Sergey Brin while they were &lt;u&gt;Ph.D. students&lt;/u&gt; at &lt;strong&gt;Stanford University&lt;/strong&gt;. &lt;/em&gt;&lt;/p&gt; Use the s Tag to Strikethrough Text（使用s标记删除线文本） 将s标签包裹在h4标签内的“Google”周围，然后在其旁边添加单词Alphabet，Alphabet不具有删除线格式。 1&lt;h4&gt;&lt;s&gt;Google&lt;/s&gt;Alphabet&lt;/h4&gt; Create a Horizontal Line Using the hr Element（使用hr元素创建水平线） 在h4标签下面添加一个hr标签 12&lt;h4&gt;&lt;s&gt;Google&lt;/s&gt;Alphabet&lt;/h4&gt;&lt;hr&gt; Adjust the background-color Property of Text（调整文本的背景颜色属性） 将h4元素的背景颜色调整为给定的rgba(45, 45, 45, 0.1)值删除height属性 并添加 padding 为 10px的填充。 12345h4 &#123; text-align: center; padding: 10px; background-color: rgba(45, 45, 45, 0.1); &#125; Adjust the Size of a Header Versus a Paragraph Tag（调整标题的大小与段落标记） 将字体大小属性添加到设置为27像素的h4元素 123456h4 &#123; text-align: center; background-color: rgba(45, 45, 45, 0.1); padding: 10px; font-size: 27px; &#125; Add a box-shadow to a Card-like Element（将盒子阴影添加到类似卡片的元素） 把id为thumbnail的元素，使用box-shadow 123#thumbnail &#123; box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);&#125; Decrease the Opacity of an Element（降低元素的不透明度） links的样式设置opacity为0.7 12345.links &#123; text-align: left; color: black; opacity: 0.7; &#125; Use the text-transform Property to Make Text Uppercase（使用text-transform属性使文本为大写） 将h4的文本text-transform属性转换为大写 1234567h4 &#123; text-align: center; background-color: rgba(45, 45, 45, 0.1); padding: 10px; font-size: 27px; text-transform: uppercase; &#125; Set the font-size for Multiple Heading Elements（设置多个标题元素的font-size） 将h1标记的font-size设置为68px将h2标记的font-size设置为52px将h3标签的font-size设置为40px将h4标记的font-size设置为32px将h5标记的font-size设置为21px将h6标记的font-size设置为14px 123456789101112131415161718h1 &#123; font-size: 68px;&#125;h2 &#123; font-size: 52px;&#125;h3 &#123; font-size: 40px;&#125;h4 &#123; font-size: 32px;&#125;h5 &#123; font-size: 21px;&#125;h6 &#123; font-size: 14px;&#125; Set the font-weight for Multiple Heading Elements（设置多个标题元素的font-weight） 将h1标记的font-weight设置为800将h2标记的font-weight设置为600将h3标签的font-weight设置为500将h4标记的font-weight设置为400将h5标记的font-weight设置为300将h6标记的font-weight设置为200 123456789101112131415161718192021222324h1 &#123; font-size: 68px; font-weight: 800;&#125;h2 &#123; font-size: 52px; font-weight: 600;&#125;h3 &#123; font-size: 40px; font-weight: 500;&#125;h4 &#123; font-size: 32px; font-weight: 400;&#125;h5 &#123; font-size: 21px; font-weight: 300;&#125;h6 &#123; font-size: 14px; font-weight: 200;&#125; Set the font-size of Paragraph Text（设置段落文本的font-size） 将段落的font-size属性值更改为16px 123p &#123; font-size: 16px; &#125; Set the line-height of Paragraphs（设置段落的line-height） 将line-height属性添加到p标记并将其设置为25px 1234p &#123; font-size: 16px; line-height: 25px; &#125; Adjust the Hover State of an Anchor Tag（调整锚标记的悬停状态） 将a标签设置为黑色。添加规则，当用户将鼠标悬停在a标记上时，颜色为蓝色 123456a &#123; color: black; &#125;a:hover &#123; color: blue; &#125; Change an Element’s Relative Position（更改元素的相对位置） 将h2的position更改为relative，并将其移动到距离正常位置top的15px 1234h2 &#123; position: relative; top: 15px;&#125; Move a Relatively Positioned Element with CSS Offsets（） 将h2 向右移动15px，向上移动10px 12345h2 &#123; position: relative; left: 15px; bottom: 10px&#125; Lock an Element to its Parent with Absolute Positioning（使用Absolute将元素锁定到其父级） 给 #searchbar的 top和right元素偏移50px 123456#searchbar &#123; position: absolute; top: 50px; right: 50px; &#125; Lock an Element to the Browser Window with Fixed Positioning（使用固定定位将元素锁定到浏览器窗口） 将其position更改为fixed，并将其偏离top 0px和left 0px 12345678#navbar &#123; position: fixed; top: 0px; left: 0px; width: 100%; background-color: #767676; &#125; Push Elements Left or Right with the float Property（使用float属性向左或向右推送元素） 给#left项left设置float，#right项right设置float数。 12345678#left &#123; float: left; width: 50%; &#125;#right &#123; float: right; width: 40%; &#125; Change the Position of Overlapping Elements with the z-index Property（使用z-index属性更改重叠元素的位置） first的元素的z-index值应为2 12345.first &#123; background-color: red; position: absolute; z-index: 2;&#125; Center an Element Horizontally Using the margin Property（使用margin属性水平居中元素） 通过添加值为auto的margin属性将页面居中放在页面上 123456div &#123; background-color: blue; height: 100px; width: 100px; margin: auto; &#125; Learn about Complementary Colors（了解互补色） blue类的div元素应具有blue的background-coloryellow类的div元素应具有yellow的background-color 123456.blue &#123; background-color: blue; &#125;.yellow &#123; background-color: yellow; &#125; Learn about Tertiary Colors（了解第三色） 将orange，cyan和raspberry的background-color属性更改为各自的颜色,确保使用十六进制代码 1234567891011.orange &#123; background-color: #FF7D00; &#125; .cyan &#123; background-color: #00FFFF; &#125; .raspberry &#123; background-color: #FF007D; &#125; Adjust the Color of Various Elements to Complementary Colors（将各种元素的颜色调整为互补色） header元素的background-color应为＃09A7A1footer元素的background-color应为＃09A7A1h2元素的color应为＃09A7A1button元素的background-color应为＃FF790E。 12345678910111213141516header &#123; background-color: #09A7A1; color: white; padding: 0.25em; &#125;footer &#123; background-color: #09A7A1; color: white; padding: 0.5em; &#125;h2 &#123; color: #09A7A1; &#125; button &#123; background-color: #FF790E; &#125; Adjust the Hue of a Color（调整颜色的色调） 使用hsl()根据类名（green, cyan, 或blue）更改每个div元素的背景颜色 123456789.green &#123; background-color: hsl(120, 100%, 50%); &#125;.cyan &#123; background-color: hsl(180, 100%, 50%); &#125;.blue &#123; background-color: hsl(240, 100%, 50%); &#125; Adjust the Tone of a Color（调整颜色的色调） 为nav元素添加背景颜色，使其使用相同的青色色调，但具有80％饱和度和25％亮度值，以改变其色调和阴影 123nav &#123; background-color: hsl(180, 80%, 25%); &#125; Create a Gradual CSS Linear Gradient（创建渐进的CSS线性渐变） 对div元素的background使用linear-gradient(），并从35deg的方向设置它以将颜色从#CCFFFF更改为#FFCCCC 1234567div&#123; border-radius: 20px; width: 70%; height: 400px; margin: 50px auto; background: linear-gradient(35deg, #CCFFFF, #FFCCCC); &#125; Use a CSS Linear Gradient to Create a Striped Element（使用CSS线性渐变来创建条带元素） 通过更改repeating-linear-gradient()以使用45deg的渐变角度来创建条纹，然后将前两个颜色设置为yellow，将最后两个颜色设置为black 12345678910111213div&#123; border-radius: 20px; width: 70%; height: 400px; margin: 50 auto; background: repeating-linear-gradient( 45deg, yellow 0px, yellow 40px, black 40px, black 80px ); &#125; Create Texture by Adding a Subtle Pattern as a Background Image（通过添加细微图案作为背景图像来创建纹理） 使用https://i.imgur.com/MJAkxbh.png的网址，使用正文选择器设置整个页面的背景 12345&lt;style&gt; body &#123; background: url(https://i.imgur.com/MJAkxbh.png); &#125;&lt;/style&gt; Use the CSS Transform scale Property to Change the Size of an Element（使用CSS Transform scale属性更改元素的大小） id为#ball2的元素大小增加到原始大小的1.5倍 1234#ball2 &#123; left: 65%; transform: scale(1.5); &#125; Use the CSS Transform scale Property to Scale an Element on Hover（使用CSS Transform scale属性在悬停上缩放元素） 为div的悬停状态添加CSS规则，当用户将鼠标悬停在其上时, 使用transform属性将div元素缩放到其原始大小的1.1倍 123div:hover &#123; transform: scale(1.1); &#125; Use the CSS Transform Property skewX to Skew an Element Along the X-Axis（使用CSS变换属性skewX, 沿X轴倾斜元素） 使用transform属性,将id为bottom的元素沿X轴倾斜24deg 1234#bottom &#123; background-color: blue; transform: skewX(24deg); &#125; Use the CSS Transform Property skewY to Skew an Element Along the Y-Axis（使用CSS变换属性skewY，沿Y轴倾斜元素） 使用transform属性，将id为top的元素沿Y轴倾斜-10deg 1234#top &#123; background-color: red; transform: skewY(-10deg); &#125; Create a Graphic Using CSS（使用CSS创建图形） 将background-color更改为transparent将border-radius属性设置为50％以形成圆形更改box-shadow属性，将offset-x设置为25px，offset-y设置为10px，blur-radius设置为0，spread-radius设置为0，颜色设置为blue 1234567891011121314.center &#123; position: absolute; margin: auto; top: 0; right: 0; bottom: 0; left: 0; width: 100px; height: 100px; background-color: transparent; border-radius: 50%; box-shadow: 25px 10px 0px 0px blue; &#125; Create a More Complex Shape Using CSS and HTML（使用CSS和HTML创建更复杂的形状） 在heart::after选择器中，将background-color更改为pink，将border-radius更改为50％在heart选择器中，填写transform属性，使用rotate()函数偏转-45deg在heart::before选择器中，将其content属性设置为空字符串 12345678910.heart &#123; transform: rotate(-45deg);&#125;.heart::after &#123; background-color: pink; border-radius: 50%; &#125;.heart::before &#123; content: &quot;&quot;;&#125; Learn How the CSS @keyframes and animation Properties Work（了解CSS @keyframes和动画属性的工作原理） 为id为rect的元素创建动画，animation-name设置为rainbow，并将animation-duration设置为4s声明一个@keyframes规则，并将动画开头的背景颜色（0％）设置为blue，将动画的中间（50％）设置为green，将动画的结尾（100％）设置为yellow 12345678910111213141516#rect &#123; animation-name: rainbow; animation-duration: 4s;&#125;@keyframes rainbow &#123; 0% &#123; background-color: blue; &#125; 50% &#123; background-color: green; &#125; 100% &#123; background-color: yellow; &#125;&#125; Use CSS Animation to Change the Hover State of a Button（使用CSS动画更改按钮的悬停状态） 使用@keyframes规则将动画名称为background-color的background-color在100％的时候更改为#4791d0 12345@keyframes background-color &#123; 100% &#123; background-color: #4791d0; &#125; &#125; Modify Fill Mode of an Animation（修改动画的填充模式） ps：因为动画在500ms过后会重置，导致按钮恢复为原始颜色，这样做会将按钮保持突出显示 button：hover应该具有值为forward的animation-fill-mode属性 12345button:hover &#123; animation-name: background-color; animation-duration: 500ms; animation-fill-mode: forwards;&#125; Create Movement Using CSS Animation（使用CSS动画创建运动） @keyframes规则0％的时候,向left偏移0px@keyframes规则50％的时候,向left偏移25px@keyframes规则100％的时候,向left偏移-25px 1234567891011121314151617@keyframes rainbow &#123; 0% &#123; background-color: blue; top: 0px; left: 0; &#125; 50% &#123; background-color: green; top: 50px; left: 25px; &#125; 100% &#123; background-color: yellow; top: 0px; left: -25px; &#125;&#125; Create Visual Direction by Fading an Element from Left to Right（通过从左到右淡化元素来创建视觉方向） @keyframes规则用于淡入淡出50％的时候, 将opacity属性设置为0.1 123456@keyframes fade &#123; 50% &#123; left: 60%; opacity: 0.1; &#125; &#125; Animate Elements Continually Using an Infinite Animation Count（动画元素不断使用无限动画计数） 要使球在连续循环中保持在右侧弹跳，请将animation-iteration-count属性更改为infinite值 123#ball &#123; animation-iteration-count: infinite;&#125; Make a CSS Heartbeat using an Infinite Animation Count（使用无限动画计数制作CSS心跳） heart类的animation-iteration-count属性应具有infinite值back类的animation-iteration-count属性应具有infinite值。 123456.back &#123; animation-iteration-count: infinite;&#125;.heart &#123; animation-iteration-count: infinite&#125; Animate Elements at Variable Rates（可变速率动画元素） 将star-1类的@keyframes规则改为50％ 123456@keyframes twinkle-1 &#123; 50% &#123; transform: scale(0.5); opacity: 0.5; &#125;&#125; Animate Multiple Elements at Variable Rates（可变速率动画多个元素）之前可以通过更改其@keyframes规则来更改两个相似动画元素的动画速率。也可以通过操纵多个元素的动画持续时间来实现相同的目标。 star-1的星的animation-duration属性应为1sstar-2的星的animation-duration属性应为0.9sstar-3的星的animation-duration属性应为1.1s 1234567891011121314151617181920.star-1 &#123; margin-top: 15%; margin-left: 60%; animation-duration: 1s; animation-name: twinkle; &#125; .star-2 &#123; margin-top: 25%; margin-left: 25%; animation-duration: 0.9s; animation-name: twinkle; &#125; .star-3 &#123; margin-top: 10%; margin-left: 50%; animation-duration: 1.1s; animation-name: twinkle; &#125; Change Animation Timing with Keywords（使用关键字更改动画计时） id为ball1的元素的animation-timing-function属性的值应该是linearid为ball2的元素的animation-timing-function属性的值是ease-out 12345678#ball1 &#123; left:27%; animation-timing-function: linear; &#125;#ball2 &#123; left:56%; animation-timing-function: ease-out; &#125; Learn How Bezier Curves Work（了解Bezier曲线的工作原理） id为ball1的元素，将animation-timing-function属性的值从linear更改为其等效的cubic-bezier函数值 1234#ball1 &#123; left: 27%; animation-timing-function: cubic-bezier(0.25, 0.25, 0.75, 0.75); &#125; Use a Bezier Curve to Move a Graphic（使用贝塞尔曲线移动图形） 将id为red的元素的animation-timing-function更改为cubic-bezier函数，其中x1，y1，x2，y2值分别设置为0,0,0.58,1 12 Make Motion More Natural Using a Bezier Curve（使用贝塞尔曲线使运动更自然） id为green的元素的animation-timing-function的值更改为cubic-bezier函数，x1，y1，x2，y2值分别设置为0.311,0.441,0.444,1.649 12345#green &#123; background: green; left: 75%; animation-timing-function: cubic-bezier(0.311, 0.441, 0.444, 1.649); &#125; 4. Applied Accessibility（应用可访问性）]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Xcode 10 library not found for -lstdc++.6.0.9]]></title>
    <url>%2F2018%2F10%2F11%2FiOS-Xcode-10-library-not-found-for-lstdc-6-0-9%2F</url>
    <content type="text"><![CDATA[下载最新的Xcode 10后出现以前的项目报错,提示找不到 -lstdc++.6.0.9 ,因为 libstdc ++在5年前被弃用了。导致 Apple 最新的Xcode也将它废弃不再支持它。stackoverflow回答 由于Apple在最新的Xcode 10.0中删除了libstdc ++，所以如果你想解决问题，可以尝试将以前Xcode 9 中的依赖库手动将文件复制到对应的lib中。1. 将Xcode 9中 iPhoneOS 和 iPhoneSimulator sdk中lib里面的 libstdc ++.6.0.9.tbd 和 libstdc ++.6.tbd 和libstdc ++.tbd 文件复制到Xcode10中： iPhoneOS.sdk/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/ iPhoneSimulator.sdk/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/ 2. 对于/usr/lib/libstdc++.6.dylib: mach-o, but not built for iOS simulator模拟器的问题,也可以将Xcode 9 中 iOS.simruntime 模拟器中lib里面的 libstdc++.6.0.9.dylib 和 libstdc++.6.dylib 和 libstdc++.dylib 文件复制到Xcode10中： iOS.simruntime/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Ubuntu安装、卸载和配置Gitlab]]></title>
    <url>%2F2018%2F06%2F03%2FLinux-Ubuntu%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BDGitlab%2F</url>
    <content type="text"><![CDATA[一、安装Gitlab1.安装并配置必要的依赖关系12sudo apt-get updatesudo apt-get install -y curl openssh-server ca-certificates 然后，安装Postfix发送通知邮件。如果您想使用其他解决方案发送电子邮件，跳过此步骤并在安装GitLab后配置外部SMTP服务器。ps:配置外部SMTP服务器: https://docs.gitlab.com/omnibus/settings/smtp.html 1sudo apt-get install -y postfix 在Postfix安装期间，可能会出现一个配置屏幕。选择 Internet Site 并按回车。使用您的服务器的外部DNS作为’邮件名’并按回车。如果出现其他屏幕，请继续按回车键以接受默认值。 2.添加GitLab软件包存储库并安装软件包 添加GitLab软件包存储库。 ps:gitlab-ce 是社区版，免费的gitlab-ee 是企业版，收费的 1234gitlab-ee:curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bashgitlab-ce: curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.deb.sh | sudo bash 接下来，安装GitLab软件包。将http：// gitlab.example.com更改为您想要访问您的GitLab实例的URL。安装将自动在该URL处配置并启动GitLab。安装后HTTPS需要额外的配置。 ps:额外的配置: https://docs.gitlab.com/omnibus/settings/nginx.html#enable-https EXTERNAL_URL为要配置的URL 1sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; apt-get install gitlab-ce 或者使用清华大学软件镜像站提供的软件源来安装 gitlab-ce https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/ 安装成功 ps: 这里提示 在/etc/gitlab/gitlab.rb文件中,设置“external_url”为GitLab配置的URL, 所以接下来需要配置gitlab 12 Please configure a URL for your GitLab instance by setting `external_url`configuration in /etc/gitlab/gitlab.rb file. 3.配置gitlab 在 /etc/gitlab/gitlab.rb 中设置 external_url ps: 如果在上一步安装 gitlab-ce 的时候配置了指定的 EXTERNAL_URL , 此步可以忽略 配置选项: https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab 12修改:external_url &apos;http://www.xxxxxxxxx.com/gitlab&apos; 重新配置Gitlab以使更改生效 1sudo gitlab-ctl reconfigure 重新启动服务 1sudo gitlab-ctl restart 4.登录gitlab 首次登录会让设置密码 ps: 用户名为root 二、卸载Gitlab 停止gitlab 1sudo gitlab-ctl stop 查看进程 1ps -e | grep gitlab 删除所有包含gitlab的文件及目录 1find / -name gitlab | xargs rm -rf 卸载 123sudo apt-get remove gitlab-ce或者sudo apt-get remove gitlab-ee 检查还有没有卸载的gitlab相关软件 1dpkg --get-selections | grep gitlab $ dpkg –get-selections|grep gitlabgitlab-ee deinstall 再执行 1sudo apt-get --purge remove gitlab-ee 三、汉化Gitlab 使用xhang提供的汉化 https://gitlab.com/xhang/gitlab 1.查看gitlab版本1cat /opt/gitlab/embedded/service/gitlab-rails/VERSION 2.下载汉化包 wget方式(指定版本) 123wget https://gitlab.com/xhang/gitlab/-/archive/10-8-stable-zh/gitlab-10-8-stable-zh.tar.bz2或者wget https://gitlab.com/xhang/gitlab/repository/10-8-stable-zh/archive.tar.bz2 -O gitlab-10-8-stable-zh.tar.bz2 git clone方式(最新版本) 1git clone https://gitlab.com/xhang/gitlab.git 解压并查看 ps:如果使用git clone方式,则无需再解压 1tar xf gitlab-10-8-stable-zh.tar.bz2 查看版本号 1234cat gitlab-10-8-stable-zh/VERSION 或者git clone方式:cat gitlab/VERSION 备份gitlab 1cp -r /opt/gitlab/embedded/service/gitlab-rails&#123;,.ori&#125; 覆盖 1sudo cp -rf gitlab-10-8-stable-zh/* /opt/gitlab/embedded/service/gitlab-rails/ 重起配置及重启gitlab 12sudo gitlab-ctl reconfiguresudo gitlab-ctl restart 四、配置Gitlab 查看gitlab配置 1sudo vim /etc/gitlab/gitlab.rb gitlab 备份 123gitlab-rake gitlab:backup:create或sudo /usr/bin/gitlab-rake gitlab:backup:create 进入/gitlab.rb修改备份路径 通过/etc/gitlab/gitlab.rb配置文件来修改默认存放备份文件的目录 1gitlab_rails[&apos;backup_path&apos;] = &quot;/xxxx/gitlab_backup&quot; 修改后再重新配置gitlab应用程序 1gitlab-ctl reconfigure 进入/gitlab.rb关闭自带nginx 1nginx[&apos;enable&apos;] = false gitlab的nginx的配置文件 gitlab的nginx是默认80端口,可以进去/gitlab-http.conf配置文件修改端口号,然后再重启 1/var/opt/gitlab/nginx/conf/gitlab-http.conf gitlab重启 1gitlab-ctl restart 五、修改Gitlab的Root密码 进入 gitlab 生产控制台 1sudo gitlab-rails console production 进入加载生产环境 (Rails 5.0.7.1) 12irb(main):001:0&gt; user = User.where(id: 1).first=&gt; #&lt;User id:1 @root&gt; 12irb(main):005:0&gt; user.password = &apos;aaaaaaaa111111111&apos;=&gt; &quot;aaaaaaaa111111111&quot; 12irb(main):006:0&gt; user.password_confirmation = &apos;aaaaaaaa111111111&apos;=&gt; &quot;aaaaaaaa111111111&quot; 123irb(main):007:0&gt; user.save!Enqueued ActionMailer::DeliveryJob (Job ID: 18cbb4be-5215-43b2-9f3d-6b8e8ca5443a) to Sidekiq(mailers) with arguments: &quot;DeviseMailer&quot;, &quot;password_change&quot;, &quot;deliver_now&quot;, #&lt;GlobalID:0x00007f227ce31ef8 @uri=#&lt;URI::GID gid://gitlab/User/1&gt;&gt;=&gt; true 1irb(main):008:0&gt; quit]]></content>
      <categories>
        <category>Linux</category>
        <category>Gitlab</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx-Ubuntu删除和部署Nginx]]></title>
    <url>%2F2018%2F05%2F26%2FLiunx-Ubuntu%E5%88%A0%E9%99%A4%E5%92%8C%E9%83%A8%E7%BD%B2Nginx%2F</url>
    <content type="text"><![CDATA[一、删除Nginx 删除Nginx及配置文件 1sudo apt-get --purge remove nginx 自动移除全部不使用的软件包 1sudo apt-get autoremove ngix 查看与Nginx相关的软件 1dpkg --get-selections|grep nginx 继续删除与Nginx有关的软件 12sudo apt-get --purge remove nginx-commonsudo apt-get --purge remove nginx-core 二、安装部署Nginx1、APT源安装(不推荐)1sudo apt-get install nginx 2、源码安装 通过官方提供的下载包进行安装 官方地址: http://nginx.org/en/download.html 1wget http://nginx.org/download/nginx-1.14.0.tar.gz 解压 1tar -zxvf nginx-1.14.0.tar.gz 进入nginx-1.14.0进行配置 1sudo ./configure 安装 1sudo make &amp;&amp; sudo make install 三、启动、重启、停止Nginx启动Nginx安装目录地址 -c Nginx指定配置文件地址 1sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 重启 检验Nginx配置文件是否正确 123// 进入sbin 文件cd /usr/local/nginx/sbin./nginx -t]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发-Flutter的SDK安装与初尝]]></title>
    <url>%2F2018%2F05%2F10%2FFlutter%E5%BC%80%E5%8F%91-Flutter%E7%9A%84SDK%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%B0%9D%2F</url>
    <content type="text"><![CDATA[前言: Flutter是Google推出使用Dart语言开发的移动应用开发框架,在昨天的 I/O 大会上谷歌特意提到了Flutter,虽然很早就发布,但是一直没有去尝试,今天就提起兴趣来尝试一把.Flutter官方: flutter.io 一、获取Flutter SDKps: 具体安装官网提示也进行了提供 下载并解压以获取Flutter SDK https://flutter.io/sdk-archive/ 解压后得到 flutter SDK以及执行文件 二、设置Flutter SDK 设置文件存放路径, 以当前用户路径~为主, 把解压后的文件存放在用户路径~下. 在 .bash_profile 文件中添加SDK路径 1export PATH=`pwd`/flutter/bin:$PATH ps: 设置完了记得 1source .bash_profile 查看 flutter 是否安装上 1flutter 查看 flutter 需要的依赖关系 1flutter doctor 开始按照提示分别安装依赖,以及插件把 三、创建项目 以Android Studio为例 值得注意的是这里提供了各个平台使用的原生语言,例如:iOS平台默认使用OC,可以选择使用Swift, Android平台默认是Java,可以选择Kotlin. 最终项目结构目录]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android开发-gradlew、adb、keytool和fastboot命令总结]]></title>
    <url>%2F2018%2F04%2F25%2FAndroid%E5%BC%80%E5%8F%91-gradlew%E3%80%81adb%E5%92%8Ckeytool%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[gradlew 查看项目依赖库依赖 ./gradlew app:dependencies 导出项目依赖库依赖至某个文件 ./gradlew app:dependencies &gt; xxxx.txt adb 查询设备 adb devices 卸载程序 adb uninstall &lt;package&gt; 覆盖安装程序(出现包名相同时使用,否则报错) adb install -r &lt;path&gt; 安装指定设备 adb -s &lt;device&gt; install -r &lt;path&gt; keytool 查询证书指纹 (SHA1) - 输入密码 keytool -list -keystore &lt;storeFile&gt; 查询证书指纹 (SHA1) keytool -list -keystore &lt;storeFile&gt; -storepass &lt;keyPassword&gt; 查询详细证书指纹 (SHA1) keytool -list -v -keystore &lt;storeFile&gt; -storepass &lt;keyPassword&gt; fastboot 查看手机进入fastboot模式连接设备 1fastboot devices 以小米手机为例, 音量- 加 电源键 fastboot 模式 如果需要擦除全部数据就把线刷包里的flash_all.sh拖进终端窗口 如果需要擦除所有数据并保留SD卡和data分区的把flash_all_except_data_storage.sh拖进终端窗口 如果需要擦除所有数据并保留SD卡数据的把flash_all_except_storage.sh拖进终端窗口]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux-Ubuntu安装openssh-server]]></title>
    <url>%2F2018%2F04%2F08%2FLinux-Ubuntu%E5%AE%89%E8%A3%85openssh-server%2F</url>
    <content type="text"><![CDATA[1.安装 openssh server 1sudo apt-get install openssh-server 2.检查当前服务状态 1234sudo service ssh statusps -s | grep sshps -e | grep ssh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web开发-Android和iOS浏览器调试手机web]]></title>
    <url>%2F2018%2F03%2F27%2FWeb%E5%BC%80%E5%8F%91-Android%E5%92%8CiOS%E7%9A%84WebView%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Chrome 浏览器调试手机webAndroid设备 浏览器输入 chrome://inspect/#devices. 然后手机设置成USB调试即可. iOS设备 这个需要依靠第三方插件:ios-webkit-debug-proxy 浏览器输入 chrome://inspect/#devices 在Discover network targets里面增加localhost:9000 运行remotedebug_ios_webkit_adapter --port=9000 Safari 浏览器调试手机web(只能调试iOS设备) 开始开发菜单 根据对应的设备进行页面选择]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发-恩智浦NXP i.MX7D开发板刷Android Things系统心得]]></title>
    <url>%2F2018%2F02%2F07%2FAndroid%E5%BC%80%E5%8F%91-%E6%81%A9%E6%99%BA%E6%B5%A6NXP-i-MX7D%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%B7Android-Things%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言:前段时间参加谷歌物联网创新沙龙,有幸抽奖得到一套恩智浦NXP i.MX7D的开发套件,和去年12月的GDD上得到的一样,近日有时间了,可以搞一搞了,自己根据官方的文档,下面分享下刷机心得. 组装套件https://developer.android.google.cn/things/hardware/imx7d-kit.html 根据官方文档步骤可以进行组装,同时还有树莓派3的操作步骤. 最后的成品就是这个样子,出现NXP的logo.(没有安装相机模块) 刷机开始一键式刷机https://developer.android.com/things/hardware/imx7d.html 还是根据官方文档的提示,在最后在步骤二的时候提示从Android Things Console下载Android Things Setup Utility. 下载Android Things Setup Utility.(如果打不开可能被墙了 -.-)https://partner.android.com/things/console/u/0/#/toolsps: 没关系,我在github传了一份,可以下载对应系统版本.https://github.com/RamboLouis/AndroidTestProject/tree/master/AndroidThings/android_things_setup_utility同时,也可以自己去租VPS.(macOS系统的 -.-)Mac环境使用DigitalOcean租用VPS 下载完成后,开始选择对应系统的安装文件,通过命令行运行. 命令行运行.遇到第一个选项:选择第一个安装Android设备,并可选择设置Wi-Fi.因为第二个是在现有的系统上设置wifi的.第二个选项:根据自己的开发板进行选择.第三个选项:根据个人喜好进行选择图形化界面.直到提示开始开始下载Android Things 安装结束,确定键继续. 设置并输入自己所在网络wifi名字和密码 点击确定退出安装. 手动刷机https://developer.android.google.cn/things/hardware/fastboot.html 需要在Android Things Console,创建项目并下载.(同样,如果打不开那就是被墙了 -.-) 按照官方文档说的,执行flash-all.sh文件 成功 Successfully flashed your imx7d. 查找并运行 输入adb devices发现可以找到设备. 通过自建项目或者官网下载demo,可以运行设备了.建议选择26以上的 结束. Holle world出现. ps:开发套件教程:https://developer.android.com/things/get-started/kits.html案例:https://developer.android.com/things/sdk/samples.htmlGoogle社区:https://plus.google.com/communities/107507328426910012281]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReactNative开发-FlatList和SectionList应用]]></title>
    <url>%2F2017%2F07%2F10%2FReactNative%E5%BC%80%E5%8F%91-FlatList%E5%92%8CSectionList%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[可参看源码具体在node_modules/react-native/Libraries/Lists的目录内.例如FlatList的源码: ../node_modules/react-native/Libraries/Lists/FlatList.js 一、什么是FlatList和SectionList FlatList和SectionList通过源码可以看出,都是基于VirtualizedList的一种封装实现. FlatList实现了单组长列表,而SectionList则实现了分组长列表. 同时也具备ScrollView的特性.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative开发-iOS设备动态获取电脑IP]]></title>
    <url>%2F2017%2F07%2F04%2FReactNative%E5%BC%80%E5%8F%91-iOS%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2ip%2F</url>
    <content type="text"><![CDATA[实际开发中需要进行真机debug调试, 但是团队开发设置的电脑IP需要灵活,不能写死,所以现在以向Xcode注入脚本的方式,动态获取电脑IP来进行. 添加运行脚本 使用ifconfig命令来获取ip 1ifconfig | grep inet\ | tail -1 | cut -d &quot; &quot; -f 2 将命令写成脚本,进行添加 123456INFOPLIST=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;&quot;echo &quot;writing to $INFOPLIST&quot;PLISTCMD=&quot;Add :SERVER_IP string $(ifconfig | grep inet\ | tail -1 | cut -d &quot; &quot; -f 2)&quot;echo -n &quot;$INFOPLIST&quot; | xargs -0 /usr/libexec/PlistBuddy -c &quot;$PLISTCMD&quot; || truePLISTCMD=&quot;Set :SERVER_IP $(ifconfig | grep inet\ | tail -1 | cut -d &quot; &quot; -f 2)&quot;echo -n &quot;$INFOPLIST&quot; | xargs -0 /usr/libexec/PlistBuddy -c &quot;$PLISTCMD&quot; || true 编辑AppDelegate.m 在iOS的AppDelegate.m中替换为预处理器指令. 1234567891011121314151617NSURL *jsCodeLocation;#if DEBUG#if TARGET_OS_SIMULATOR #warning &quot;DEBUG SIMULATOR&quot; jsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;];#else #warning &quot;DEBUG DEVICE&quot; NSString *serverIP = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;SERVER_IP&quot;]; NSString *jsCodeUrlString = [NSString stringWithFormat:@&quot;http://%@:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;, serverIP]; NSString *jsBundleUrlString = [jsCodeUrlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; jsCodeLocation = [NSURL URLWithString:jsBundleUrlString];#endif#else #warning &quot;PRODUCTION DEVICE&quot; jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];#endif 参考文献:https://github.com/facebook/react-native/issues/4245http://moduscreate.com/automated-ip-configuration-for-react-native-development/]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative开发-React Navigation应用]]></title>
    <url>%2F2017%2F06%2F25%2FReactNative%E5%BC%80%E5%8F%91-React-Navigation%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言:目前开始对项目进行重构了,看了一月的安卓重新开始对RN中旧的和所用的框架进行重新梳理. 从0.44版本开始,Navigator被从React Native的核心组件库中剥离到了一个名为react-native-deprecated-custom-components的单独模块中.如果你需要继续使用Navigator,则需要先npm i -S react-native-deprecated-custom-components，然后从这个模块中import，即import { Navigator } from &#39;react-native-deprecated-custom-components&#39;. 不过在0.45版本之后官方主推的方案是一个单独的导航库React Navigation. 对于导航路由来说:在iOS端有UINavigationController控件,其采用的是”栈”的方式管理子控件,对新进来的子控制器进行压栈(push)处理,同时也用来控制界面跳转.而安卓端,由于框架设计思路不同,没有导航控件一说,其跳转界面通过需要通过开启活动(Activity),方可跳转另一界面.但是对于ReactNative来说,新的导航框架(React Navigation),整体设计思路更偏向于iOS,对于局部细节,例如需要事先声明被跳转模块等.也有安卓的影子. 官方文档: https://reactnavigation.org/docs/intro/ 下面就结合React Navigation集成到项目进行练习. 一、在项目中安装 React Navigation1npm install --save react-navigation 二、React Navigation框架里面有什么 StackNavigator: 可是实现屏幕上方导航栏,类似iOS中的UINavigationController. TabNavigator: 可是实现屏幕底部多个选项,类似iOS中的UITabBarController,但是同时也可以通过修改属性把TabNavigator放在顶部. 三、什么是Stack NavigationStack Navigation是React Navigation框架中的一个具有顶部导航功能的子模块,其使用特点类似iOS的UINavigationController,采用”栈”的概念来进行导航的,每个新控制器放在堆栈的顶部,返回时从栈顶移除. 在项目中创建了一个app.js的类,在index.android.js和index.ios.js分别调用这个类. 更新: RN 在0.49的以后的版本中取消了index.android.js和index.ios.js这个两个文件,10月04日之后创建的项目统一成index.js. 0.49的以前: index.android.js和index.ios.js0.49的以后: index.js 12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;import App from &apos;./src/containers/app/app&apos;;import &#123; AppRegistry,&#125; from &apos;react-native&apos;;export default class TestReactNativeProject extends Component &#123; render() &#123; return ( &lt;App /&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;TestReactNativeProject&apos;, () =&gt; TestReactNativeProject); App.js类 12345678910import React, &#123; Component &#125; from &apos;react&apos;import NavStackNavigator from &apos;../app/StackNavigator&apos;export default class App extends Component&lt;&#123;&#125;&gt; &#123; render () &#123; return ( &lt;NavStackNavigator /&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发-Adapter和AdapterView.]]></title>
    <url>%2F2017%2F06%2F05%2FAndroid%E5%BC%80%E5%8F%91-Adapter%2F</url>
    <content type="text"><![CDATA[Adapter Adapter从字面意思了解就是适配器，类似于iOS中UITableView和UICollectionView中的数据源。 对于列表和九宫格控件，安卓也有类似iOS的ListView和GridView。 由于ListView和GridView都继承于抽象类AbsListView，这个类中有一个setAdapter的方法，通过这个方法可以设置具体需要展示的数据。 12以listView为例:listView.setAdapter(otherAdapter); 与iOS中遵守数据源协议，实现数据源方法类似。 不过在iOS中对于列表和九宫格控件有着各自的数据源协议和函数，而安卓平台上把这个进行了解耦，通过对象的形式一个Adapter可以添加到多个控件，控件则进行样式的展示而已。 ArrayAdapter 官方提供了基于BaseAdapter的ArrayAdapter，ArrayAdapter可以看出采用泛型操作（数组、集合等），文档也说明，在默认情况下提供单个TextView操作，所以如果出现单个文本的情况还是可以采用的。 源码已经看出提供单个TextView进行赋值。 12345678910111213141516171819202122232425262728293031323334353637383940private @NonNull View createViewFromResource(@NonNull LayoutInflater inflater, int position, @Nullable View convertView, @NonNull ViewGroup parent, int resource) &#123; final View view; final TextView text; if (convertView == null) &#123; view = inflater.inflate(resource, parent, false); &#125; else &#123; view = convertView; &#125; try &#123; if (mFieldId == 0) &#123; // If no custom field is assigned, assume the whole resource is a TextView text = (TextView) view; &#125; else &#123; // Otherwise, find the TextView field within the layout text = (TextView) view.findViewById(mFieldId); if (text == null) &#123; throw new RuntimeException(&quot;Failed to find view with ID &quot; + mContext.getResources().getResourceName(mFieldId) + &quot; in item layout&quot;); &#125; &#125; &#125; catch (ClassCastException e) &#123; Log.e(&quot;ArrayAdapter&quot;, &quot;You must supply a resource ID for a TextView&quot;); throw new IllegalStateException( &quot;ArrayAdapter requires the resource ID to be a TextView&quot;, e); &#125; final T item = getItem(position); if (item instanceof CharSequence) &#123; text.setText((CharSequence) item); &#125; else &#123; text.setText(item.toString()); &#125; return view;&#125; Layout样式： simple_list_item_1 纯文本 simple_expandable_list_item_1 纯文本“膨胀”版 simple_list_item_checked 文本后加对号选项 simple_list_item_single_choice 文本后加圆形选项 simple_list_item_multiple_choice 文本后加方块选项等 代码实现： 1234567891011121314151617181920212223strArr = new ArrayList&lt;&gt;();for (int i = 1; i &lt;= listNum; i++) &#123; strArr.add(&quot;测试&quot;+i);&#125;// 纯文字列表// arrayAdapter = new ArrayAdapter(this,android.R.layout.simple_list_item_1,strArr);// 纯文字列表（加高）// arrayAdapter = new ArrayAdapter(this,android.R.layout.simple_expandable_list_item_1,strArr);// 加一个对号选项// arrayAdapter = new ArrayAdapter(this,android.R.layout.simple_list_item_checked,strArr);// 加一个原点选项//arrayAdapter = new ArrayAdapter(this,android.R.layout.simple_list_item_single_choice,strArr);// 加一个方块选项arrayAdapter = new ArrayAdapter(this,android.R.layout.simple_list_item_multiple_choice,strArr);listView = (ListView)findViewById(R.id.arrayAdapterListView);listView.setAdapter(arrayAdapter);listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Log.d(TAG, &quot;你点击了第&quot; + position + &quot;项&quot;); &#125;&#125;); SimpleAdapter SimpleAdapter也是基于BaseAdapter的，相比ArrayAdapter增加了ImageView，同时layout样式是可以自己设定的，如果只是简单的图片和文字可以使用SimpleAdapter。 之前在思考为什么只有文字和图片，通过源码可以看出，再给每个item赋值的时候分别判断TextView和ImageView的实例存在。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void bindView(int position, View view) &#123; final Map dataSet = mData.get(position); if (dataSet == null) &#123; return; &#125; final ViewBinder binder = mViewBinder; final String[] from = mFrom; final int[] to = mTo; final int count = to.length; for (int i = 0; i &lt; count; i++) &#123; final View v = view.findViewById(to[i]); if (v != null) &#123; final Object data = dataSet.get(from[i]); String text = data == null ? &quot;&quot; : data.toString(); if (text == null) &#123; text = &quot;&quot;; &#125; boolean bound = false; if (binder != null) &#123; bound = binder.setViewValue(v, data, text); &#125; if (!bound) &#123; if (v instanceof Checkable) &#123; if (data instanceof Boolean) &#123; ((Checkable) v).setChecked((Boolean) data); &#125; else if (v instanceof TextView) &#123; // Note: keep the instanceof TextView check at the bottom of these // ifs since a lot of views are TextViews (e.g. CheckBoxes). setViewText((TextView) v, text); &#125; else &#123; throw new IllegalStateException(v.getClass().getName() + &quot; should be bound to a Boolean, not a &quot; + (data == null ? &quot;&lt;unknown type&gt;&quot; : data.getClass())); &#125; &#125; else if (v instanceof TextView) &#123; // Note: keep the instanceof TextView check at the bottom of these // ifs since a lot of views are TextViews (e.g. CheckBoxes). setViewText((TextView) v, text); &#125; else if (v instanceof ImageView) &#123; if (data instanceof Integer) &#123; setViewImage((ImageView) v, (Integer) data); &#125; else &#123; setViewImage((ImageView) v, text); &#125; &#125; else &#123; throw new IllegalStateException(v.getClass().getName() + &quot; is not a &quot; + &quot; view that can be bounds by this SimpleAdapter&quot;); &#125; &#125; &#125; &#125;&#125; 判断实例完再给文本和图片设置值。 1234567public void setViewText(TextView v, String text) &#123; v.setText(text);&#125;public void setViewImage(ImageView v, int value) &#123; v.setImageResource(value);&#125; 代码： 123456789101112131415161718192021222324 List&lt;Map&lt;String,Object&gt;&gt; listItems = new ArrayList&lt;&gt;();for (int i = 0; i &lt; icons.length; i++) &#123; Map&lt;String,Object&gt; item = new HashMap&lt;&gt;(); item.put(&quot;icon&quot;,icons[i]); item.put(&quot;name&quot;,names[i]); item.put(&quot;subName&quot;,subNames[i]); item.put(&quot;subIcon&quot;,icons[i]); item.put(&quot;subNames2&quot;,subNames2[i]); listItems.add(item);&#125;simpleAdapter = new SimpleAdapter( this, listItems, R.layout.layout_item, new String[]&#123;&quot;icon&quot;,&quot;name&quot;,&quot;subName&quot;,&quot;subIcon&quot;,&quot;subNames2&quot;&#125;, new int[]&#123;R.id.imageView, R.id.textView, R.id.textView2, R.id.imageView2, R.id.textView3&#125;);listView = (ListView)findViewById(R.id.simpleAdapterListView);listView.setAdapter(simpleAdapter);listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Toast.makeText(getApplicationContext(),&quot;你点击了第&quot; + position + &quot;项&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;); layout: 通过ConstraintLayout来进行布局。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginBottom=&quot;10dp&quot; app:srcCompat=&quot;@color/colorAccent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; android:layout_marginStart=&quot;10dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; android:textSize=&quot;20sp&quot; app:layout_constraintTop_toTopOf=&quot;@+id/imageView&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/imageView&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginStart=&quot;10dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; android:textSize=&quot;14sp&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/textView&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/textView&quot; android:layout_marginTop=&quot;5dp&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView2&quot; android:layout_width=&quot;10dp&quot; android:layout_height=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:srcCompat=&quot;@color/colorAccent&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView3&quot; android:layout_width=&quot;58dp&quot; android:layout_height=&quot;17dp&quot; android:text=&quot;TextView&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/imageView2&quot; android:layout_marginRight=&quot;0dp&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; BaseAdapter 通过Adapter继承结构图可以看到，Adapter为一个抽象接口,基于这个抽象接口的有一个抽象实现类BaseAdapter. 对于BaseAdapter，在实际开发过程中，大多数都会继承这个类，并重写其方法，定制自己的Adapter，其高度的解耦性，这点和iOS有所不同。 相对来讲SimpleAdapter和ArrayAdapter用的少，都是自己重写或者使用第三方Adapter。 源码：https://github.com/RamboLouis/AndroidTestProject/tree/master/AndroidAdapter]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发-Activity.]]></title>
    <url>%2F2017%2F05%2F28%2FAndroid%E5%BC%80%E5%8F%91-Activity%2F</url>
    <content type="text"><![CDATA[Activity Android应用程序四大组件之一,一个 Activity 通常就是一个单独的屏幕,用户可与其提供的屏幕进行交互。每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。类似于iOS中的UIViewController。 每次新 Activity 启动时，前一 Activity 便会停止，但系统会在堆栈（“返回栈”）中保留该 Activity。 Activity之间通过Intent进行通信。 创建 Activity 创建 Activity，必须创建 Activity 的子类。 onCreate() 必须实现此方法。系统会在创建您的 Activity 时调用此方法。在这个方法实现内初始化 Activity 的必需组件。 同时必须在此方法内调用 setContentView()，以定义 Activity 用户界面的布局。 onPause() 系统将此方法作为用户离开 Activity 的第一个信号进行调用（但并不总是意味着 Activity 会被销毁）。通常应该在此方法内确认在当前用户会话结束后仍然有效的操作（因为用户可能不会返回）。 配置 AndroidManifest 更改默认Activity。 1234567&lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=&quot;.MainActivity&quot; /&gt; ... &lt;/application ... &gt; ...&lt;/manifest &gt; intent-filter 123456&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; action 元素指定这是应用的“主”入口点。category 元素指定此 Activity 应列入系统的应用启动器内。 启动 Activity 可以通过调用 startActivity()，并将其传递给描述您想启动的 Activity 的 Intent 来启动另一个 Activity。 启动某个已知 Activity。 可以通过使用类名创建一个显式定义您想启动的 Activity 的 Intent 对象来实现此目的。 例如，可以通过以下代码让一个 Activity 启动另一个名为 HomeActivity 的 Activity： 显式启动:通过包名来启动 12Intent intent = new Intent(XXX.this, HomeActivity.class);startActivity(intent); 隐式启动:通过AndroidManifest中的Intent-filter的Action,Category来实现。 1234567 &lt;activity android:name=&quot;.OtherActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;other_action&quot; /&gt; &lt;category android:name=&quot;other_category&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 1234Intent otherIntent = new Intent();otherIntent.setAction(&quot;other_action&quot;);otherIntent.addCategory(&quot;other_category&quot;);startActivity(otherIntent); 应用还可以利用 Activity 数据执行某项操作，例如打电话、发短信、发电子邮件等。 12345678910111213// 打电话Uri uri = Uri.parse(&quot;tel:10010&quot;);Intent intent = new Intent(Intent.ACTION_DIAL, uri);startActivity(intent);// 2. 发短信Uri uri = Uri.parse(&quot;sms:10010&quot;);Intent intent = new Intent(Intent.ACTION_SENDTO, uri);intent.putExtra(&quot;sms_body&quot;, &quot;今天天气不错&quot;);startActivity(intent);// 3. 打开浏览器Uri uri = Uri.parse(&quot;http://www.baidu.com&quot;);Intent intent = new Intent(Intent.ACTION_VIEW, uri);startActivity(intent); 启动 Activity 以获得回调结果从启动的 Activity 获得回调结果。在这种情况下，请通过调用 startActivityForResult()（而非 startActivity()）来启动 Activity。 要想在随后收到后续 Activity 的结果，请实现 onActivityResult() 回调方法。 当后续 Activity 完成时，它会使用 Intent 向 onActivityResult() 方法返回结果。 管理 Activity 生命周期 onCreate(): 类似iOS中的viewDidLoad。 首次创建 Activity 时调用。始终后接 onStart()。 onStart(): 类似iOS中的viewWillAppear。 在 Activity 即将对用户可见之前调用。如果 Activity 转入前台，则后接 onResume()，如果 Activity 转入隐藏状态，则后接 onStop()。 onResume(): 类似iOS中的viewDidAppear。 在 Activity 即将开始与用户进行交互之前调用。始终后接 onPause()。 onRestart(): 在 Activity 已停止并即将再次启动前调用。始终后接 onStart() onPause(): 当系统即将开始继续另一个 Activity 时调用。 onStop(): 在 Activity 对用户不再可见时调用。如果 Activity 恢复与用户的交互，则后接 onRestart()，如果 Activity 被销毁，则后接 onDestroy()。 onDestroy(): 在 Activity 被销毁前调用。 Activity的启动顺序： onCreate()—&gt;onStart()—&gt;onResume() 当 Activity A 启动 Activity B 时发生顺序： 1.Activity A 的 onPause() 方法执行。 2.Activity B 的 onCreate()、onStart() 和 onResume() 方法依次执行。 3.因为 Activity A 在屏幕上不再可见，则其 onStop() 方法执行。 从 Activity B 返回到 Activity A时： 1.Activity B 的 onPause() 方法执行 2.Activity A 的 onRestart()、onStart()、onResume() 方法以此执行。 3.Activity B 的 onStop()、onDestroy()依次执行。 Activity的销毁顺序: onPause()—&gt;onStop()—&gt;onDestroy() Activity 正向传值及反向回调正向传值 Activity A 传递一个或多个参数 1234567891011Intent intent = new Intent(MainActivity.this, UserActivity.class);// 一次传一个intent.putExtra(&quot;name&quot;,name);// 一次传多条数据Bundle bd = new Bundle();bd.putCharSequence(&quot;name&quot;,name);bd.putCharSequence(&quot;sex&quot;,sex);intent.putExtras(bd);startActivity(intent); Activity B 接收一个或多个参数 123456789Intent getIntent = getIntent();// 一次取一个name = getIntent.getStringExtra(&quot;name&quot;);// 一次取多个Bundle bd = getIntent.getExtras();name = bd.getCharSequence(&quot;name&quot;).toString();sex = bd.getCharSequence(&quot;sex&quot;).toString(); 反向回调 Activity A 使用带Result的方法 startActivityForResult() 来启动 Activity B，而非 startActivity() 来启动 Activity B。 12Intent intent = new Intent(OtherActivity.this,ImageActivity.class);startActivityForResult(intent,100); Activity B 则实现 setResult()方法来实现回传值。 123Intent intent = getIntent();setResult(200,intent);finish(); 这样 Activity A 就会收到 Activity B 的回调结果，Activity A 再实现 onActivityResult() 回调方法进行监听。 requestCode 为 Activity A 中 startActivityForResult() 发送的第二个参数: 100resultCode 为 Activity B 中setResult()发送的第一个参数: 200Intent 为 Activity B 中的Intent 1234567@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); Log.d(TAG, &quot;requestCode-----&gt;&quot; + requestCode); Log.d(TAG, &quot;resultCode---&gt;&quot; + resultCode); &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发-java迁移Kotlin以及Kotlin与Swift对比学习.]]></title>
    <url>%2F2017%2F05%2F18%2FAndroid%E5%BC%80%E5%8F%91-Android%E8%BF%81%E7%A7%BBKotlin%E4%BB%A5%E5%8F%8A%E4%B8%8ESwift%E7%9A%84%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[前言:北京时间的17日23点,谷歌一年一度的I/O开发者大会召开.就在这第一天,谷歌安卓团队大会上宣布Kotlin成为Android的主力开发语言,其实在之前这个语言就已经支持了安卓平台开发，但是直到今天谷歌开发者大会上才宣布对该语言的全面支持和维护,至此之后代码将更加简洁.最近项目上线,CTO说闲暇之余学习下安卓,无奈重新啃java的语法,这是多么痛的领悟,可是一觉醒来,万物复苏.作为热衷Swift的iOS开发者,看到Kotlin语法是多么的熟悉.23333. 一、Kotlin的迁移.1、安装一个Kotlin的插件.Ps:使用Android Studio开发安卓.听说Android Studio 3.0 预览版已支持 Kotlin了,就可以跳过这一步了. Android Studio -&gt; Preferences -&gt; Plugins 选择Browse Repositories 搜索Kotlin 根据提示重启Android Studio即可. 2、java文件迁移KotlinKotlin插件提供了迁移入口, jetbrains真是良心卖家啊. 打开你的Activity, 选择 code -&gt; Convert Java File to Kotlin File Ps:和Swift迁移感觉一样, 原本java文件的MainActivity: 12345678910111213package com.example.rambolu.testkotlin;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 迁移后kt文件的MainActivity:Ps:迁移后发现眼前的画面似曾相识… 123456789101112package com.barryzhang.kotlinhelloimport android.support.v7.app.AppCompatActivityimport android.os.Bundleclass MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125;&#125; 对比swift文件的ViewController:Ps：真的和Kotlin是孪生姐妹… 123456789101112131415import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125; 感觉当你写惯了swift后,在书写方式上稍微熟悉下可以无缝切入Kotlin.至于android的类库还需要再进一步的学习. 同时Kotlin和java也可以进行混编(有点类似OC和Swift混编),Kotlin可以调用java的类库,同时java也可以调用Kotlin. 3、配置Kotlin. 当你转移后,再次打开Activity,IDE会提醒你Kotlin not configured.此时需要点击右面的configure. 点击后会提醒项目配置Kotlin,是选择选择默认状态(All modules containing Kotlin files: app),以及Kotlin的版本就即可.Ps: 配置完,其实是在你项目中的build.gradle中添加了Kotlin版本和路径(不是app-&gt;build.gradle) 以及你的app-&gt;build.gradle中添加了Kotlin的依赖 配置完,提示需要同步才能正常工作,此时需要点击同步. 好了,现在可以运行了. 二、Kotlin与Swift对比学习. 作为官方主推,势必要成为开发的趋势,笔者认为早上车,早体验代码的简洁,同时也提高了开发效率，对于Swift可以更进一步研究FP和POP,而不是还在因为一个property里面的修饰符思考半天. 相比Kotlin,目前版本1.1,有如两年前的Swift,对于比Swift开源还早的语言,看来没有大财主也是无济于事啊,之前谷歌与甲骨文的官司,感觉谷歌也是没有办法,也想加紧更换开发Android的语言,这才导致谷歌宣布Swift的孪生姐妹Kotlin成为主力语言. 对比学习主要也是更直观的对比2种语言的书写方式,以及书写规范,方便掌握,也加深对语言的认识. Kotlin的官方文档:http://kotlinlang.org/docs/reference/basic-syntax.html民间翻译中文版:https://huanglizhuo.gitbooks.io/kotlin-in-chinese/Basics/Basic-Types.htmlSwift的官方文档:https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309以及Kotlin和Swift对比文档http://nilhcem.com/swift-is-like-kotlin/以下简单举例语法的相似之处,具体开发中涉及到的类库还要看各家介绍. 常量和变量 12345Swiftlet :常量 ,var :变量var a : Int = 0 a = 1let b = 2 12345Kotlin 也支持类型推导val :常量 ,var :变量var a : Int = 1 a = 2val b = 1 打印Holle world 12Swiftprint(&quot;Hello, world!&quot;) 12Kotlinprint(&quot;Hello, world!&quot;) println(&quot;Hello, world!&quot;) // 和Swift 1.0中使用到的类似 打印嵌套字符串区别在于一个是\,一个是$,以及大小括号 1234Swiftlet name = &quot;rambolu&quot;let age = 25print(&quot;我的名字: \(name), 我的年龄 : \(age) &quot;) 1234Kotlinval name = &quot;rambolu&quot;val age = 25println(&quot;我的名字: $&#123;name&#125;, 我的年龄 $&#123;age&#125; &quot;) 数组 for in循环 12345Swiftlet arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]for i in 0..&lt;arr.count &#123; print(&quot; \(i) + \(arr[i])&quot;)&#125; 123456Kotlinval arr = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)val count = arr.count()for (i in 0..count - 1) &#123; println(&quot;$&#123;i&#125; + $&#123;arr[i]&#125;&quot;)&#125; 持续补充 三、后记 Kotlin的成长似乎也伴随着Swift成长,从苹果把Swift的开源,以及成为主力开发语言至今,苹果一直在激进般的前行,现在谷歌也把Kotlin成为Android的主力开发语言,瞬间感觉以后的开发都在降低了开发者的学习成本,代码都更加的简洁,方便其他开发者更快捷的开发app应用. Kotlin团队也宣称 Kotlin 将在 Android Studio 3.0中直接提供,这也意味着开发Android不再需要安装任何插件和担心兼容性的问题了.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift学习-面向协议编程中associatedtype的认识]]></title>
    <url>%2F2017%2F04%2F19%2FSwift%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%E4%B8%ADassociatedtype%E7%9A%84%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html 在定义协议时，有时将一个或多个关联类型声明为协议定义的一部分是有用的。一个相关联的类型给出了一个占位符名称到被用作协议的一部分的类型。在采用协议之前，不会指定用于该关联类型的实际类型。关联类型用associatedtype关键字指定。 这里是一个叫做协议的例子Container，它声明一个关联的类型Item： 123456protocol Container &#123; associatedtype Item mutating func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125;&#125; 该Container协议定义了三种所需的功能，任何容器必须提供： 必须使用append(_:)方法向容器添加一个新项目。 必须可以通过count返回Int值的属性访问容器中的项目计数。 必须可以使用具有Int索引值的下标来检索容器中的每个项目。 该协议不指定应该如何存储容器中的项目或者允许的类型。该协议仅指定任何类型必须提供的功能的三位，以便被认为是Container。只要满足这三个要求，一致的类型可以提供附加的功能。 符合Container协议的任何类型必须能够指定其存储的值的类型。具体来说，它必须确保仅将正确类型的项目添加到容器中，并且必须清楚其下标返回的项目的类型。 要定义这些要求，Container协议需要一种方法来引用容器将要容纳的元素的类型，而不需要知道特定容器的类型。该Container协议需要指定传递给任何值append(_:)方法必须具有相同的类型容器的元件的类型，以及通过所述容器的下标所返回的值将是相同的类型容器的元件的类型。 为了实现这一点，该Container协议声明称为关联的类型Item，写为associatedtype Item 该协议没有定义什么Item是 - 为任何符合类型提供的信息。尽管如此，Item别名提供了一种方法来引用a中的项目的类型Container，并定义与append(_:)方法和下标一起使用的类型，以确保Container强制执行any的预期行为。 这是一个非常IntStack类型的版本，适用于符合Container协议： 123456789101112131415161718192021struct IntStack: Container &#123; // original IntStack implementation var items = [Int]() mutating func push(_ item: Int) &#123; items.append(item) &#125; mutating func pop() -&gt; Int &#123; return items.removeLast() &#125; // conformance to the Container protocol typealias Item = Int mutating func append(_ item: Int) &#123; self.push(item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Int &#123; return items[i] &#125;&#125; 该IntStack类型实现了Container协议的所有三个要求，并且在每种情况下都包含了IntStack类型现有功能的一部分以满足这些要求。 此外，IntStack规定了对于这种实现Container，适合Item使用的是一种Int。将该typealias Item = Int抽象类型的定义Item转化为具体类型Int的该Container协议的实现。 感谢Swift的类型推断，实际上并不需要声明具体Item的Int定义IntStack。由于IntStack符合Container协议的所有要求，所以Swift可以Item通过查看append(_:)方法参数的item类型和下标的返回类型来推断适用的方法。实际上，如果你typealias Item = Int从上面的代码中删除一行，那么所有内容都仍然有效，因为它应该是什么类型的Item。 你也可以使通用Stack类型符合Container协议： 1234567891011121314151617181920struct Stack&lt;Element&gt;: Container &#123; // original Stack&lt;Element&gt; implementation var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // conformance to the Container protocol mutating func append(_ item: Element) &#123; self.push(item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Element &#123; return items[i] &#125;&#125; 此时，type参数Element用作append(_:)方法参数的item类型和下标的返回类型。因此，Swift可以推断出这Element是特定容器使用的适当类型Item。 扩展现有类型以指定关联类型 你可以扩展现有类型以添加​​符合协议，如添加协议与扩展一致性所述。这包括具有关联类型的协议。 Swift的Array类型已经提供了一个append(_:)方法，一个count属性和一个带Int索引的下标来检索它的元素。这三个功能符合Container协议的要求。这意味着你可以通过声明采用协议来扩展Array以符合协议。你可以使用空的扩展名来执行此操作，如使用扩展名声明协议采用所述： ContainerArray 1extension Array: Container &#123;&#125; Array的现有append(_:)方法和下标使Swift能够推断Item适用于的Stack类型，就像上面的泛型一样。定义此扩展名后，你可以使用任何Array作为Container。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go学习-Mac环境配置Golang开发环境及学习项目.]]></title>
    <url>%2F2017%2F03%2F25%2FGo%E5%AD%A6%E4%B9%A0-Mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEGolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[一、下载安装Golang的SDK. Go下载官网:https://golang.org/dl/ 二、配置环境变量 默认安装目录 /usr/local/go 目录 编辑环境变量 1vi ~/.bash_profile GOPATH是项目目录，根据自己的项目设置. GOPATH如果有多个目录，用冒号:分割 12345export GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport GOARCH=amd64export GOOS=darwinexport GOPATH=/Users/用户名/Desktop/xxxx1:/Users/用户名/Desktop/xxxx2 编译生效 1source ~/.bash_profile 查看Go环境变量 1go env 三、使用Gogland或IDEA安装Go插件GOPATH下需要建立3个目录：bin 存储编译后的可执行文件；pkg 存放编译后生成的包文件；src 存放项目的源码； 四、Golang项目一个golang电子书介绍如何与golang建立一个网站:https://github.com/astaxie/build-web-application-with-golang高性能Web框架:https://github.com/astaxie/beego]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods进阶-制作私有Cocoapods仓库。]]></title>
    <url>%2F2017%2F03%2F05%2FCocoapods%E8%BF%9B%E9%98%B6-%E5%88%B6%E4%BD%9C%E7%A7%81%E6%9C%89Cocoapods%E4%BB%93%E5%BA%93%E3%80%82%2F</url>
    <content type="text"><![CDATA[1.克隆仓库到本地1git clone ********** 2.制作仓库索引文件 .podspec1pod spec create xxxxxxx 3.编辑 podspec 文件12345678910111213141516171819202122232425Pod::Spec.new do |s| s.name = &quot;LuKit&quot; // 仓库名字 s.version = &quot;0.0.1&quot; // 仓库版本 s.summary = &quot;A custom framework.&quot; // 仓库简介，搜索的关键词 s.homepage = &quot;https://github.com/RamboLouis/LuKit&quot; // 主页地址 s.license = &quot;MIT&quot; // 许可证 # s.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125; s.author = &#123; &quot;RamboLu&quot; =&gt; &quot;coderambolu@gmail.com&quot; &#125; // 作者 # s.platform = :ios s.platform = :ios, &quot;9.0&quot; // 仓库使用平台 s.source = &#123; :git =&gt; &quot;https://github.com/RamboLouis/LuKit.git&quot;, :tag =&gt; s.version &#125; // Git仓库地址 s.source_files = &quot;Classes/*.swift&quot; // 需要包含的源文件 s.requires_arc = true // 是否要求ARC # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; // 仓库中只用到的依赖库 # s.pod_target_xcconfig = &#123; &apos;SWIFT_VERSION&apos; =&gt; &apos;3.0&apos; &#125; // 指定只用swift 3.0版本end 4.打标签和推送版本Ps: 命令行和SourceTree方式。 命令行方式 1234567// 推送版本git add -A &amp;&amp; git commit -m &quot;Release 1.0.0.&quot;git push origin master// 打标签git tag &apos;1.0.0&apos;git push --tags SourceTree方式 Ps: 推送版本。 Ps: 打标签。 5.验证.podspec编辑好后最好先验证 .podspec 是否有有效 1pod spec lint Ps: 验证成功。 6.发布到CocoaPodsCocoaPods 现在使用Trunk 服务来发布自己的pod，所以需要 注册 pod账户 1pod trunk register ******@***.com &quot;****&quot; 查询注册信息 1pod trunk me 推送到pod仓库 1pod trunk push ******.podspec Ps: 推送成功。 PS：出现问题 source_files找不到匹配文件 1- ERROR | [iOS] file patterns: The `source_files` pattern did not match any file. 建议：更改成Classes为根目录。]]></content>
      <categories>
        <category>Cocoapods</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative学习-什么是iflux?]]></title>
    <url>%2F2017%2F03%2F03%2FReactNative%E5%AD%A6%E4%B9%A0-%E4%BB%80%E4%B9%88%E6%98%AFiflux%2F</url>
    <content type="text"><![CDATA[什么是iflux ?iflux = immutable.js + react.js 什么是React.js ?React.js犹如Facebook的文化基因所强调的一样move fast and break things, 在快速前进中打破了很多我们对于web开发的固有认识。更厉害的是React把这种创新平移到移动开发(React native)实现了Learn once, Write everywhere. React的特点。 强调组件化的开发方式（更高的抽象层次，更好的分离关注点） 声明式的开发风格（更好的表现力） 单向的数据流动（简单可预测） 超高性能的渲染60fps不是梦 （掌声在哪里？） 最大的创新源于virtual dom （以及virtual native） 轻量，可以在现有的系统中快速试错 精确的生命周期，更简单的整合第三方的库(jquery) 关于更多因为React的定位就是轻量级高效组件式的view library，但是在我们实际的应用开发工程中不仅仅需要处理view的问题，更复杂的是对于状态的控制。官方的flux架构提供了一个很好的针对React的架构指导，但是代码量很大。说到底flux就是在解决一个数据流向以及控制状态变化问题。这点om确实做的非常出色，借助于Clojure的数据的特性（1. 数据不可变 2. 持久化数据结构 3.共享数据结构）在不断的追寻下，immutable.js出现在了眼前，如获至宝。随着对immutable.js深入挖掘，发现正好契合了React的架构特点，可以使用Immutable很好的管理我们的Store，因为Immutable强调值语义，能够更好的追踪状态的变化(cursor)且带来了更好的性能。 整体思路 建议：优先选择connectToStore 1234567891011121314151617181920+-----------------------+| WebApi |+-----------------------+ | \|/+-----------------------+| Store（immutable） |&lt;-----++-----------------------+ | | //es5的风格 | | StoreMixin | msg(EventEmitter) \|/ |+------------------------+ || React App |-----|+------------------------+| &lt;Layout&gt; || &lt;SearchForm/&gt; || &lt;Toolbar/&gt; || &lt;DataGrid/&gt; || &lt;/Layout&gt; |+------------------------+ 一个应用只有一个Store，单根数据源，单向数据流动，数据沉淀在顶层。且通过PureRenderMix可以获取更好的性能。简直就是为React私人定制一般。 于是，顺其自然的写了iflux去更好的粘合React和immutable。 整体思路： React只承担view应该承担的事情（1. 资料呈现 2. 用户交互） 不处理任何的业务逻辑，就是根据数据去渲染dom即可，这样view可以做的很轻。 应用的全部数据沉淀在一个Store中，当全部数据在顶层时，很多事情都变得简单，因为获取数据变得十分廉价。无论是校验和对数据的转换控制都变得非常简单。 React只是取数据渲染，其他的比如状态的变化全部通过事件pubsub通知appstore去更新数据。如果状态不会影响其他组件的级联变化可以放在组件内部消化掉。 所有的ajax封装在webapi模块中，全部promise化。回调回来通过cursor更新store, cursor更新store， store通知React去rerender。 区分View component 和 pure component。 如何使用?123456mkdir hellocd hellonpm initnpm install react immutable iflux --savenpm install babel-loader --save-dev 12345678910111213➜ iflux-demo tree -L 3.├── apps #we like django&apos;s app-style│ └── index #app-name│ ├── index.js #viewcontainer component│ ├── component #collect of dump components│ ├── store.js #immutable store│ └── webapi.js #fetch remote resource├── node_modules├── package.json└── webpack.config.js5 directories, 4 files 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//webapi.jsexport const fetchGithub = (name) =&gt; &#123; return fetch(`http://github.com/$&#123;name&#125;`)&#125;;export default &#123; fetchGithub&#125;;//store.jsimport &#123; Store, msg &#125; from 'iflux';import &#123; fromJS &#125; from 'immutable';import &#123; fetchGithub &#125; from './webapi';const appStore = Store(&#123; name: '', githubInfo: &#123;&#125;&#125;);exports default appStore;//when use immutable's cursor to update store//react's view will auto re-rendermsg.on('updateName', (name) =&gt; &#123; appStore.cursor().set('name', name);&#125;);msg.on('submit', async () =&gt; &#123; const data = await fetchGithub(name); appStore.cursor.set('githubInfo', fromJS(data));&#125;);//index.js//es5的样式import React from 'react';import &#123;msg, mixins&#125; from 'iflux';import appStore from './store';const &#123;StoreMixin&#125; = mixins;const IfluxApp = React.createClass(&#123; //自动将Store中的data混入到state mixins: [StoreMixin(appStore)], render() &#123; var store = appStore.data(); return ( &lt;div&gt; &lt;form onSubmit=&#123;this._submit&#125;&gt; &lt;input name="name" onChange=&#123;this._handleChange&#125;/&gt; &lt;/form&gt; &lt;div&gt; &#123;store.get('githubInfo')&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;, _handleChange(e) &#123; msg.emit('updateName', e.target.value); &#125;, _submit() &#123; msg.emit('getGithubInfo'); &#125;&#125;);//es6的样式import React from 'react';import &#123; msg, connectToStore &#125; from 'iflux';import appStore from './store';class IfluxApp extends React.Component &#123; render() &#123; const &#123;store&#125; = this.props; return ( &lt;div&gt; &lt;form onSubmit=&#123;this._submit&#125;&gt; &lt;input name="name" onChange=&#123;this._handleChange&#125;/&gt; &lt;/form&gt; &lt;div&gt; &#123;store.get('githubInfo')&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default connectToStore(appStore)(IfluxApp);]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative学习-state与props介绍与比较]]></title>
    <url>%2F2017%2F02%2F28%2FReactNative%E5%AD%A6%E4%B9%A0-state%E4%B8%8Eprops%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[State state的作用 state是React中组件的一个对象.React把用户界面当做是状态机,想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致. React中,更新组件的state,会导致重新渲染用户界面(不要操作DOM).简单来说,就是用户界面会随着state变化而变化. state工作原理 常用的通知React数据变化的方法是调用setState(data,callback).这个方法会合并data到this.state,并重新渲染组件.渲染完成后,调用可选的callback回调.大部分情况不需要提供callback,因为React会负责吧界面更新到最新状态. 那些组件应该有state? 大部分组件的工作应该是从props里取数据并渲染出来.但是,有时需要对用户输入,服务器请求或者时间变化等作出响应,这时才需要state. 组件应该尽可能的无状态化,这样能隔离state,把它放到最合理的地方(Redux做的就是这个事情?),也能减少冗余并易于解释程序运作过程. 常用的模式就是创建多个只负责渲染数据的无状态(stateless)组件,在他们的上层创建一个有状态(stateful)组件并把它的状态通过props传给子级.有状态的组件封装了所有的用户交互逻辑,而这些无状态组件只负责声明式地渲染数据. 哪些应该作为state? state应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据.这中数据一般很小且能被JSON序列化.当创建一个状态化的组件的时候,应该保持数据的精简,然后存入this.state.在render()中在根据state来计算需要的其他数据.因为如果在state里添加冗余数据或计算所得数据,经常需要手动保持数据同步. 那些不应该作为state? this.state应该仅包括能表示用户界面状态所需要的最少数据.因此,不应该包括: 计算所得数据: React组件:在render()里使用props和state来创建它. 基于props的重复数据:尽可能保持用props来做作为唯一的数据来源.把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化. props props的作用 组件中的props是一种父级向子级传递数据的方式. 复合组件 123456789101112131415161718192021222324252627282930313233var Avatar = React.createClass(&#123; 2 render: function() &#123; 3 return ( 4 &lt;div&gt; 5 &lt;ProfilePic username=&#123;this.props.username&#125; /&gt; 6 &lt;ProfileLink username=&#123;this.props.username&#125; /&gt; 7 &lt;/div&gt; 8 ); 9 &#125;10 &#125;);11 12 var ProfilePic = React.createClass(&#123;13 render: function() &#123;14 return (15 &lt;img src=&#123;&apos;http://graph.facebook.com/&apos; + this.props.username + &apos;/picture&apos;&#125; /&gt;16 );17 &#125;18 &#125;);19 20 var ProfileLink = React.createClass(&#123;21 render: function() &#123;22 return (23 &lt;a href=&#123;&apos;http://www.facebook.com/&apos; + this.props.username&#125;&gt;24 &#123;this.props.username&#125;25 &lt;/a&gt;26 );27 &#125;28 &#125;);29 30 React.render(31 &lt;Avatar username=&quot;pwh&quot; /&gt;,32 document.getElementById(&apos;example&apos;)33 );]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative学习-React.js生命周期]]></title>
    <url>%2F2017%2F02%2F27%2FReactNative%E5%AD%A6%E4%B9%A0-React-js%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期官方文档: https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate 当创建组件的实例并将其插入到DOM中时，将调用这些方法： 1、constructor() React组件的构造函数。在安装React组件的构造函数之前调用它。在实现Component子类的构造函数时，应该在任何其他语句之前调用super（props）。 1234&gt; constructor(props) &#123; super(props);&#125;&gt; 2、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 3、 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 4、componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 更新可能是道具或状态的改变引起的。当重新呈现组件时，将调用这些方法： 6、componentWillReceivePorps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 7、shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接收新的state或者props时调用，默认为true，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。对于初始渲染，调用this.forceUpdate（）会跳过此步骤不调用此方法。 8、componentWillUpdata(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state如果shouldComponentUpdate（）返回false，则不会调用componentWillUpdate（） 9、render() 根据diff算法渲染视图 10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。如果shouldComponentUpdate（）返回false，则不会调用componentDidUpdate（）。 当从DOM中删除组件时调用此方法： 11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac、Linux环境自定义终端-oh my zsh安装及配置]]></title>
    <url>%2F2017%2F02%2F25%2FMac%E3%80%81Linux%E7%8E%AF%E5%A2%83%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%88%E7%AB%AF-oh%20my%20zsh%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装oh my zsh:1.克隆这个项目到本地（根路径 ~） 1git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2.创建一个zsh的配置文件 注意:如果你已经有一个~/.zshrc文件的话，建议你先做备份。 备份配置文件 1cp ~/.zshrc ~/.zshrc.orig 然后开始创建zsh的配置文件 1cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 3.查看系统内置了几种shell 1cat /etc/shells 4.设置zsh为你的默认的shell 1chsh -s /bin/zsh ps: Linux会提示找不到/bin/zsh,需要手动安装zsh.以下以Ubuntu为例: 1234* 更新软件源sudo apt-get update* 安装zshsudo apt-get install zsh 5.重启终端ps: Ubuntu最后没有效果,需要重启电脑,可以手动点设置也可以用下面命令重启. 1sudo reboot 更改zsh主题:1.编辑 ~/.zshrc 2.修改主题Ps：主题文件在 ~/.oh-my-zsh/themes 目录 1ZSH_THEME=&quot;ys&quot; 终端启动速度慢:检查~/.bash_profile或~/.zshrc的预加载运行命令ps: 删除多余命令,重新启动终端 安装插件:1.下载插件到.oh-my-zsh/plugins目录 zsh-autosuggestions 自动提示插件 1git clone git://github.com/zsh-users/zsh-autosuggestions /Users/&#123;用户名&#125;/.oh-my-zsh/plugins/zsh-autosuggestions zsh-syntax-highlighting 命令输入高亮 命令输入正确会绿色高亮显示，输入错误会显示其他的颜色 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git /Users/&#123;用户名&#125;/.oh-my-zsh/plugins/zsh-syntax-highlighting 2.配置.zshrc文件 找到plugins=(git), 每个插件中间空格 1plugins=(git &#123;插件名&#125;) 3.关闭终端重新打开 1source ~/.zshrc]]></content>
      <categories>
        <category>Mac</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Linux</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境使用DigitalOcean租用VPS，部署Docker容器搭建SS和VPN专属梯子及Docker命令整理]]></title>
    <url>%2F2017%2F02%2F21%2FMac%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8DigitalOcean%E7%A7%9F%E7%94%A8VPS%EF%BC%8C%E9%83%A8%E7%BD%B2Docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BASS%E5%92%8CVPN%E4%B8%93%E5%B1%9E%E6%A2%AF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[技术在于折腾。 由于平时查阅受限，导致一些国外优秀的文章在国内无法查看，故自己动手丰衣足食。（ps：仅限技术交流，不用于商业用途） 关于VPS有很多种，例如：DigitalOcean、BandwagonHost、Vultr等，可以根据自己的经济能力自行选择。 以DigitalOcean举例 一、官网注册https://cloud.digitalocean.com/ps：注册费用$5，现在还送$10，一共$15,如果选用最便宜的服务器，可以使用3个月。当然,你也可以租用别家的VPS,适合自己就好. 二、创建虚拟服务器 三、选择服务器 系统默认是乌班图，喜欢CoreOS、CentOS可以自行选择 价钱是每月的使用费以及设备的配置，如果平时上网话，5刀的足以 线路使用纽约、旧金山都可以，建议使用旧金山的 四、选择连接方式，建议使用ssh连接(安全) ps：关于配置ssh可以在settings里面找到。 生成ssh，可以参考github官方生成文档：https://help.github.com/articles/connecting-to-github-with-ssh/ 查看ssh,可以通过查找文件输入 ~/.ssh的方式 具体查看公钥 1cat ~/.ssh/id_rsa.pub 再把查看的公钥粘贴至对话框 五、连接服务器及部署 连接服务器，生成的IP地址 1ssh root@xxx.xxx.xxx.xxx 1.通过部署Docker容器方式1sudo apt-get install docker.io ps：如果出现部署不上，出现如下情况，执行下面命令。 情况一: 提示需要更新。 1sudo apt-get update 情况二: 找不到docker.io(Ubuntu里，Docker叫docker.io)，那就采用其它安装方式安装最新版本的Docker。此命令会把Docker官方提供的最新版本的软件仓库替换Ubuntu的相应仓库。有一点要注意，采用这种方式进行安装，Docker的软件包名应该叫lxc-docker。此时，Docker命令的名字还是docker。而采用之前上面的安装方式，Docker命令的名字应该叫docker.io。 1curl -sSL https://get.docker.com/ | sudo sh 再升级Docker 1sudo apt-get update &amp;&amp; sudo apt-get upgrade 2. 通过部署脚本方式 脚本仓库： https://github.com/uxh/shadowsocks_bash 1wget --no-check-certificate -O shadowsocks-libev_CN.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/shadowsocks-libev_CN.sh &amp;&amp; bash shadowsocks-libev_CN.sh 六、连接（一）、通过Docker容器方式部署连接仓库1、通过shadowsocks(ss)连接. 通过DockerHub搜索docker-shadowsocks DockerHub地址: https://hub.docker.com/r/oddrationale/docker-shadowsocks/ 从DockerHub上,拉取shadowsocks容器 1docker pull oddrationale/docker-shadowsocks 设置仓库的端口、密码、及加密方式ps：xxxxxx 是你要设置的密码1984 是你的端口号 1docker run -d -p 1984:1984 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 1984 -k xxxxxx -m aes-256-cfb 对于为什么端口的设置，因为在启动镜像时，宿主机映射到docker容器上的端口必须要和shadowsocks上的设置的端口一致，换句话说就是冒号后边的端口号和最后的端口必须要保证一致。因为想要外界能够访问容器内部应用，就需要给从宿主机通过-p参数给宿主机和容器之间的端口形成一对一的映射来访问，而容器内则需要保证shadowsocks的端口和被映射端口一致即可。 查看docker 列表 ps：如果出现up就表明部署成功 1docker ps 2、通过IPsec VPN连接. 通过DockerHub搜索ipsec DockerHub地址: https://hub.docker.com/r/hwdsl2/ipsec-vpn-server/ 从DockerHub上,拉取shadowsocks容器 1docker pull hwdsl2/ipsec-vpn-server 运行 IPsec VPN 服务器 1sudo modprobe af_key 使用本镜像创建一个新的Docker容器 (env文件里面是指定变量的,需要自己单独创建) Ps: 自己创建env文件并把自己定义的名字写在里面 VPN_USER: 用户名 VPN_PASSWORD: 用户密码 123VPN_IPSEC_PSK=your_ipsec_pre_shared_keyVPN_USER=your_vpn_usernameVPN_PASSWORD=your_vpn_password Ps: 下面代码需要全部写在终端里面,当然也可以不加 --env-file ./env \ 这一行,如果不写VPN_USER 会默认为 vpnuser，并且 VPN_IPSEC_PSK 和 VPN_PASSWORD 会被自动随机生成。 ipsec-vpn-server: 容器名字 ./env: 变量名字路径 4500: 端口 123456789docker run \ --name ipsec-vpn-server \ --env-file ./env \ --restart=always \ -p 500:500/udp \ -p 4500:4500/udp \ -v /lib/modules:/lib/modules:ro \ -d --privileged \ hwdsl2/ipsec-vpn-server 获取 ipsecVpn 登录信息 1docker logs ipsec-vpn-server 1docker logs xxxx: 容器名字 在命令输出中查找这些代码：Connect to your new VPN with these details:Server IP: your_vpn_server_ipIPsec PSK: your_ipsec_pre_shared_keyUsername: your_vpn_usernamePassword: your_vpn_password 添加vpn地址 共享密钥填写IPsec PSKs （二）、 通过脚本方式部署连接仓库 选择安装: 1 设置密码、端口及加密方式 ps: 加密方式建议选择 aes-256-cfb 回车安装，安装成功 安装过程会经历几分钟，然后把配置信息保存好 七、添加服务器 下载ss客户端（shadowsocks），并添加。 GitHub官方提供下载dmg：https://github.com/shadowsocks/shadowsocks-iOS/releases ps: 新一代shadowsocks客户端：https://github.com/shadowsocks/ShadowsocksX-NG/releases 安装后配置服务器，打开服务器设置，并添加服务器。 把创建的服务器Ip、端口号及创建的加密方式密码填入即可 ps：如果是通过Docker安装的，默认端口号填写的1984，加密方式选择aes-256-cfb 八、Docker命令 查看安装容器 1docker ps 暂停容器 ps: 查询过后NAMES,为启动镜像后随机生成的容器名. 1docker stop xxx(容器名字) 删除容器ps: 删除容器前需要暂停容器 1docker rm xxx(容器名字) 启动容器 1docker start xxx(容器名字) 拉取安装镜像仓库 1docker pull xxx(镜像名字) 查看下载镜像仓库 1docker images 删除下载镜像仓库 1docker rmi xxx(镜像名字)]]></content>
      <categories>
        <category>Mac</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>进阶</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node之Package.json文件参数解析]]></title>
    <url>%2F2017%2F02%2F13%2FNode%E4%B9%8Bpackage-json%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[参考JavaScript 标准参考教程（alpha）http://javascript.ruanyifeng.com/nodejs/packagejson.html#toc0 概述 package.json在Node项目中用于描述项目的一些基本信息，以及依赖库的配置，一般每一个Node项目的根目录下都有一个package.json文件。 在项目的根目录中package.json文件可以手工编写，也可以使用npm init命令自动生成，其内容是一个Json对象。 1npm init 基本结构如下： 12345678910111213141516171819&#123; &quot;name&quot;: &quot;package&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.23.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.1.8&quot;, &quot;hexo&quot;: &quot;^3.2.0&quot;, &quot;immutable&quot;: &quot;^3.8.1&quot;, &quot;iflux&quot;: &quot;^1.2.16&quot; &#125;, &quot;devDependencies&quot;: &#123;&#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; scripts字段参考文献npm scripts 使用指南 By阮一峰http://www.ruanyifeng.com/blog/2016/10/npm_scripts.htmlscripts的每一个属性，对应一段脚本。是指定了运行脚本命令的npm命令行缩写，比如start 属性指定了运行npm run start时，所要执行的命令。 123npm run start# 等同于执行node index.js 下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。 123456&quot;scripts&quot;: &#123; &quot;preinstall&quot;: &quot;echo here it comes!&quot;, &quot;postinstall&quot;: &quot;echo there it goes!&quot;, &quot;start&quot;: &quot;node index.js&quot;, &quot;test&quot;: &quot;tap test/*.js&quot;&#125; dependencies字段，devDependencies字段dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。 123456&#123; &quot;devDependencies&quot;: &#123; &quot;browserify&quot;: &quot;~13.0.0&quot;, &quot;karma-browserify&quot;: &quot;~5.0.1&quot; &#125;&#125; 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本。 安装所需要的模块吗，直接使用npm install命令。 1npm install XXXX 如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。 123npm install express --savenpm install express --save-dev 上面代码表示单独安装express模块，–save 表示将该模块写入dependencies属性，–save-dev 表示将该模块写入devDependencies属性。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative学习-React技术栈全家桶]]></title>
    <url>%2F2016%2F12%2F24%2FReactNative%E5%AD%A6%E4%B9%A0-React-js%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[React 技术栈系列教程http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html React.js 入门教程http://www.ruanyifeng.com/blog/2015/03/react.html ECMAScript 6 入门http://es6.ruanyifeng.com/#docs/style ReactNative 中文网http://reactnative.cn Immutable.js 官方文档http://facebook.github.io/immutable-js/ Immutable 详解及 React 中实践https://zhuanlan.zhihu.com/p/20295971?columnSlug=purerender Flux 架构入门教程http://www.ruanyifeng.com/blog/2016/01/flux.html Flux 架构官方英文文档https://facebook.github.io/flux/docs/overview.html#content Redux 入门教程（一）：基本用法http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html Redux 入门教程（二）：中间件（middleware）与异步操作http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html Redux 入门教程（三）：React-Redux 的用法http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html Redux.js 官方英文文档http://redux.js.org Redux.js GitHub中文文档http://cn.redux.js.org/docs/react-redux/api.html Flex 布局教程：语法篇http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool 浅谈 React、Flux 与 Reduxhttp://www.tuicool.com/articles/3AFJNbj 怎样理顺react，flux，redux这些概念的关系，开发中有必要使用它们吗?https://www.zhihu.com/question/47686258/answer/107209140 DEMO文章：这段时间看了下Redux，写自己对它的感觉。http://react-china.org/t/redux/2687 基于 react + react-router + redux + webpack + ES6/7 + less 的完整项目https://github.com/bailicangdu/react-pxq 基于webpack + react + react-router + redux + less + flex.css + ES6 的React版cnode社区http://react-china.org/t/webpack-react-react-router-redux-less-flex-css-es6-react-cnode/6332 概述大前端的时代来了，还不要准备好么？ 做React需要会什么？react的功能其实很单一，主要负责渲染的功能，现有的框架，比如angular是一个大而全的框架，用了angular几乎就不需要用其他工具辅助配合，但是react不一样，他只负责ui渲染，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上，还有单元测试等。 React 是什么用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。 React的组件化react的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。 React的 Diff算法react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。 对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。 React组件是怎么来的组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。 这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。 当我们使用组件&lt; Main /&gt;时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。 有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。 组件的生命周期官方文档: https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate 当创建组件的实例并将其插入到DOM中时，将调用这些方法： 1、constructor() React组件的构造函数。在安装React组件的构造函数之前调用它。在实现Component子类的构造函数时，应该在任何其他语句之前调用super（props）。 1234&gt; constructor(props) &#123; super(props);&#125;&gt; 2、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 3、 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 4、componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 更新可能是道具或状态的改变引起的。当重新呈现组件时，将调用这些方法： 6、componentWillReceivePorps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 7、shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接收新的state或者props时调用，默认为true，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。对于初始渲染，调用this.forceUpdate（）会跳过此步骤不调用此方法。 8、componentWillUpdata(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state如果shouldComponentUpdate（）返回false，则不会调用componentWillUpdate（） 9、render() 根据diff算法渲染视图 10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。如果shouldComponentUpdate（）返回false，则不会调用componentDidUpdate（）。 当从DOM中删除组件时调用此方法： 11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。 React-Router路由Router就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。 当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。 1234567891011121314151617181920212223242526272829const chooseProducts = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/chooseProducts').default) &#125;,'chooseProducts')&#125;const helpCenter = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/helpCenter').default) &#125;,'helpCenter')&#125;const saleRecord = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/saleRecord').default) &#125;,'saleRecord')&#125;const RouteConfig = ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path="/" component=&#123;Roots&#125;&gt; &lt;IndexRoute component=&#123;index&#125; /&gt;//首页 &lt;Route path="index" component=&#123;index&#125; /&gt; &lt;Route path="helpCenter" getComponent=&#123;helpCenter&#125; /&gt;//帮助中心 &lt;Route path="saleRecord" getComponent=&#123;saleRecord&#125; /&gt;//销售记录 &lt;Redirect from='*' to='/' /&gt; &lt;/Route&gt; &lt;/Router&gt;); 组件之间的通信react推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。 组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。 兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。 组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。 Redux首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。 先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。 流程是这个样子的： 值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。 接下来具体分析一下，redux以及react-redux到底是怎么实现的。先上一张图 明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析： 先说说redux：redux主要由三部分组成：store，reducer，action。store是一个对象，它有四个主要的方法： 1、dispatch: 用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。 2、subscribe： 监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。let unsubscribe = store.subscribe(() =&gt; {console.log(‘state发生了变化’)}) 3、getState： 获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。 4、replaceReducer: 替换reducer，改变state修改的逻辑。 store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。 action: action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。 reducer: reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。 像这个样子：12345const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;) combineReducers: 其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。 接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，reducer会根据state的key值获取与自己对应的state，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。 redux的state和react的state两者完全没有关系，除了名字一样。 上面分析了redux的主要功能，那么react-redux到底做了什么？ React-Redux如果只使用redux，那么流程是这样的： component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component 用了react-redux之后流程是这样的： component –&gt; actionCreator(data) –&gt; reducer –&gt; component store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。 Provider是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过contex获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。 connect –connect(mapStateToProps, mapDispatchToProps, mergeProps, options)是一个函数，它接受四个参数并且再返回一个函数–wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。 所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component) mapStateToProps(state, [ownProps])： mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps 123function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125; mapDispatchToProps(dispatch, [ownProps])： mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的 123456function mapDispatchToProps(dispatch) &#123; return &#123; todoActions: bindActionCreators(todoActionCreators, dispatch), counterActions: bindActionCreators(counterActionCreators, dispatch) &#125;;&#125; mapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。 mergeProps(stateProps, dispatchProps, ownProps)： 将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。 options： pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。 其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。 下面是一个完整的 react –&gt; redux –&gt; react 流程：一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。 三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react –&gt; redux –&gt; react 的一次流程结束。 上面的有点复杂，简化版的流程是： 一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。 connect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。 简化版本：1connect(state =&gt; state, action)(Component); 项目搭建上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。 1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。 2、从 react.js，redux，react-router 中引入所需要的对象和方法。12345import React, &#123;Component, PropTypes&#125; from 'react';import ReactDOM, &#123;render&#125; from 'react-dom';import &#123;Provider, connect&#125; from 'react-redux';import &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router'; 3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。 4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。 5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。 6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。 7、将Router放入最顶层组件Provider，引入store作为Provider的属性。 8、调用render渲染Provider组件且放入页面的标签中。 可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。 通常我们在顶层的ui组件打印props时可以看到一堆属性： 上图的顶层ui组件属性总共有18个，如果刚刚接触react，可能对这些属性怎么来的感到困惑，其实这些属性来自五个地方： 组件自定义属性1个，actionCreator返回的对象6个，reducer返回的state4个，Connect组件属性0个，以及Router注入的属性7个。]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative学习-MAC集成环境]]></title>
    <url>%2F2016%2F12%2F08%2FReactNative%E5%AD%A6%E4%B9%A0-MAC%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[官网有更详细的集成步骤，这里只是根据个人需求写出简单实用的集成步骤。 1.配置环境按照HomeBrew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装Node.js1brew install node 替换npm仓库镜像源123npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 安装WatchmanWatchman是由Facebook提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能 1brew install watchman 2.安装工具包安装RN命令行工具包1npm install -g yarn react-native-cli 遇到EACCES: permission denied权限报错，需要修复/usr/local目录的所有权： 1sudo chown -R `whoami` /usr/local 3.创建React Native测试项目主要是需要 cd 到对应文件目录，再init， ”testProject“ 名字是自定义的 1react-native init testProject 如果报错, 无法创建. 尝试使用使用下面的命令更新brew及对应的工具123brew updatebrew upgrade 打开项目, 找到iOS文件夹中的工程文件运行即可]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift学习-Swift3.0已出坑，适配iOS10,项目迁移Swift3.0问题总结。]]></title>
    <url>%2F2016%2F10%2F15%2FSwift%E5%AD%A6%E4%B9%A0-Swift3-0%E5%B7%B2%E5%87%BA%E5%9D%91%EF%BC%8C%E9%80%82%E9%85%8DiOS10-%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BBSwift3-0%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E3%80%82%2F</url>
    <content type="text"><![CDATA[前言 Swift项目,为适配iOS10,无奈只能更新Xcode 8 ,可是发现一入3.0深似海,从此幸福是路人.于是边摸索边修改,在节前的完成代码迁移.节后在完成手头工作后,整理思路,把Swift3.0迁移的心得分享大家.废话不多说分享下心得: 1、代码篇:(一定要做好备份!!!) 1&gt;升级Xcode8正式版(8A218a). 2&gt;使用系统自带的桥接工具.(原装的就是好,直接打开2.2项目也会提醒-&gt;步骤:3)Edit &gt; Convert &gt; To Current Swift Syntax.. 3&gt;不用说就是为3.0来的,选择Swift3. 4&gt;上面的框架就不用选了,只选择.app的.(这个是检测代码,不然你会哭的) 5&gt;检测完后.在左边的选择页中选择好要转移的代码,左边的代码是Swift3.0代码,右侧代码时swift2.2代码-&gt;点Save. 2、第三方框架篇:(使用的cocoapods管理的第三方框架) 1&gt;发现框架报错.(不要怕,按照错误一样一样来)* 问题1:–.第三方框架版本问题,”Use Legacy Swift Language Version”“Use Legacy Swift Language Version” (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit &gt; Convert &gt; To Current Swift Syntax…] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.在pod的配置文件里面的Use Legacy Swift Language Version选择YES错误就消除了Pods-&gt;TARGETS-&gt;指定框架 -&gt; Build Settings -&gt; Use Legacy Swift Language Version * 问题2:–.lipo:can’t open input file:xxx(No such file or directory) PROJRCT-&gt; Build Settings -&gt; Build Active Architecture only-&gt;YES 其他问题后续收集再整理… 2&gt;发现框架过时,需要更新框架.由于3.0的更新,Swift各个主流框架都已经及时的推出了新的版本,例如:Alamofire 4.0.0 , SnapKit 3.0.0 , Kingfisher 3.1.0 , SwiftyJSON 也已经更新了专供Swift3的分支.所以,要更新框架以供使用. 1234pod &apos;SnapKit&apos;, &apos;~&gt; 3.0.0&apos;pod &apos;SwiftyJSON&apos;, :git =&gt; &apos;https://github.com/acegreen/SwiftyJSON.git&apos;, :branch =&gt; &apos;swift3&apos;pod &apos;Alamofire&apos;,&apos;~&gt; 4.0.0&apos;pod &apos;Kingfisher&apos;,&apos;~&gt; 3.1.0&apos; 可能会出现以下问题: * SnapKit框架问题: 看到200多个框架错误后凌乱了.都是3.0语法了,为什么还会报错,不在框架,在自己安装的cocoapods环境有关系. 解决方案:需要更新最新环境到cocoapods 1.1.0.rc.2 1sudo gem install cocoapods --pre 可以参照SnapKit的官方issues:https://github.com/SnapKit/SnapKit/issues/300如果没有安装 cocoapods可以参照之前写的博客.安装 cocoapods 1.1.0心得体会: * Alamofire框架问题: Alamofire/Source/ServerTrustPolicy.swift:243:41: Use of unresolved identifier ‘kSecTrustResultInvalid’ Alamofire的官方issues:https://github.com/Alamofire/Alamofire/issues/1541 解决方案:上面也提到了,更新最新的Alamofire框架. 1pod &apos;Alamofire&apos;,&apos;~&gt; 4.0.0&apos; 可能还遇到的问题: 12345[!] Unable to satisfy the following requirements:- `Alamofire (~&gt; 4.0.0)` required by `Podfile`Specs satisfying the `Alamofire (~&gt; 4.0.0)` dependency were found, but they required a higher minimum deployment target. 解决方法:Alamofire 4.0.0 最低要求系统版本9.0,已经将系统升高到9.0还是无法安装.目前的没有找到有效的解决方法,只有一个方案就是重新立项先集成框架,在把转接完的代码迁移到新的项目中去. 10月24日,更新解决方法.之前提示Alamofire 4.0.0, Podfile报错.需要在Podfile文件中指定最低系统9.0项目版本.platform :ios,&#39;9.0&#39;Alamofire的官方issues:https://github.com/Alamofire/Alamofire/issues/1639 * 可能还会有其他框架问题,目前还没有遇到.欢迎讨论.3.其他问题总结: * 关于重建工程来迁移到Swift3.0解决方案.前面也提到了,发现有个别问题无法解决,一直解决也是没有成效,于是使用目前来说最简洁的方法就重新建立工程. 先把新建的工程集成好最新支持Swift3.0的第三方框架,测试程序可不可以跑通后,再把之前转换完的代码一个分类一个分类迁移到新的工程里面. 至于手工拖入的第三方依赖库,应用跳转,按照之前集成好的照搬.或者重新集成. * Swift3.0语法的学习.1.官方已经给出文档以及转变说明.Apple Swift 3.0官方文档:The Swift Programming Language (Swift 3) 2.Apple Swift 3.0官方演变:apple/swift-evolution/releases/swift-3_0.md 其主要是废除了一些API,简化代码的书写,例如取出OC中的NS类前缀,C语言的风格,等等. 3.国外raywenderlich的Swift 3.0迁移介绍:https://www.raywenderlich.com/135655/whats-new-swift-3 * 后续持续补充.后记 对Swift3的书写方式还需要进一步的加强,虽然和之前的写法有着轻微的改动,使整体变的更加的简洁、严谨,但是稍不注意还是出现莫名其妙的报错. 展望Swift4,让暴风雨来的更猛烈些吧. 欢迎讨论、批评、指正.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods进阶-屡试不爽，安装Cocoapods1.1.0最新心得及问题总结]]></title>
    <url>%2F2016%2F10%2F07%2FCocoapods%E8%BF%9B%E9%98%B6-%E5%B1%A1%E8%AF%95%E4%B8%8D%E7%88%BD%EF%BC%8C%E5%AE%89%E8%A3%85Cocoapods1.1.0%E6%9C%80%E6%96%B0%E5%BF%83%E5%BE%97%E5%8F%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93!%2F</url>
    <content type="text"><![CDATA[安装淘宝源就直接跳过,安装十余次,分享下最近安装cocoapods的经验,仅仅提醒ruby版本问题之后的操作.如果还有不懂地方可以下方评论,会及时回答.12Error installing cocoapods: activesupport requires Ruby version &gt;= 2.2.2. 1.安装ruby1&gt;安装 RVMRVM: Ruby Version Manager, Ruby的版本管理器，包括Ruby的版本管理和Gem库管理(gemset) 1curl -L get.rvm.io | bash -s stable 2&gt;安装home-brew(切记先安装home-brew,再安装ruby!!)1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; home-brew地址: http://brew.sh 如果出现重复安装home-brew,不要怕. 会给你提示命令.It appears Homebrew is already installed. If your intent is to reinstall youshould do the following before running this installer again: 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; 3&gt;再安装ruby版本(最新版本2.3.0)1rvm install 2.3.0 出现情况:1.安装不通过的话可以进行手动安装. Installing requirements for osx.Updating system…..Installing required packages: autoconf, automake, libtool, pkg-config, libyaml, readline, libksba, openssl|……..Error running ‘requirements_osx_brew_libs_install autoconf automake libtool pkg-config libyaml readline libksba openssl’,showing last 15 lines of /Users/MTKJ/.rvm/log/1469285314_ruby-2.3.0/package_install_autoconf_automake_libtool_pkg-config_libyaml_readline_libksba_openssl.log 12345678brew install autoconfbrew install automakebrew install lib toolbrew install apple-gcc42brew install libyamlbrew install libxsltbrew install libksbabrew install openssl 2 . Error running ‘__rvm_make -j 1’ 错误 ruby-2.3.0 - #extracting ruby-2.3.0 to /Users/xxxx/.rvm/src/ruby-2.3.0…-ruby-2.3.0 - #configuring………………………………………………|ruby-2.3.0 - #post-configuration.ruby-2.3.0 - #compiling………..Error running ‘__rvm_make -j 1’,showing last 15 lines of /Users/xxxx/.rvm/log/1476689284_ruby-2.3.0/make.logcompiling dln.ccompiling localeinit.ccreating verconf.hverconf.h updatedcompiling loadpath.ccompiling prelude.clinking static-library libruby.2.3.0-static.averifying static-library libruby.2.3.0-static.alinking shared-library libruby.2.3.0.dylibgenerating encdb.hencdb.h updatedmaking enc/bin/sh: /Applications/Xcode: No such file or directorymake: *** [enc] Error 127++ return 2There has been an error while running make. Halting the installation./Users/xxxx/.rvm/bin/rvm: line 66: shell_session_update: command not found 安装xcode command line 后再次安装ruby. 1xcode-select --install 如果还是没有成功,查看自己xcode command line 是否选在正确版本. 4&gt;出现错误了,还是没有安装成功ruby.(没关系,卸载RVM,从新安装!)要记得关闭终端重新打开, 或者打开路径cd ~出现在~ 1sudo rm -rf .rvm .rvmrc /etc/rvmrc ;gem uninstall rvm 2.安装CocoaPods1&gt;安装cocoapods(普通版本)1sudo gem install cocoapods 2&gt;更新框架库1pod setup 可以查看框架镜像库的cd ~/.cocoapods 3&gt;更新cocoapods版本(测试版本,仅供特定条件)1sudo gem install cocoapods --pre 4&gt;指定安装cocoapods版本1sudo gem install cocoapods --version 1.0.1 出现情况: Could not find a valid gem ‘cocoapods’ (&gt;= 0), here is why:Unable to download data from https://gems.ruby-china.org - bad response Not Found 404 (https://gems.ruby-china.org/specs.4.8.gz) 问题是因为gem 的ruby 镜像源发生了更换，切换镜像源即可。 1234567https://gems.ruby-china.org =&gt; https://gems.ruby-china.com// 查看 镜像源gem sources -l// 删除 镜像源gem sources --remove https://gems.ruby-china.org// 添加 镜像源gem sources -a https://gems.ruby-china.com 详情可参照ruby中国镜像社区： https://gems.ruby-china.com/]]></content>
      <categories>
        <category>Cocoapods</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby学习-Ruby版本安装与切换.]]></title>
    <url>%2F2016%2F09%2F20%2FRuby%E5%AD%A6%E4%B9%A0-Ruby%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Ruby版本管理器（RVM）官网:https://rvm.io/ RVM使用指南:https://ruby-china.org/wiki/rvm-guide 一、安装 RVMRVM: Ruby Version Manager, Ruby的版本管理器，包括Ruby的版本管理和Gem库管理(gemset).1curl -L get.rvm.io | bash -s stable 二、Ruby源 查看当前 Ruby 源 1gem sources -l 删除当前 Ruby 源 1gem sources --remove ****** 使用指定 Ruby 源 1gem sources -a ****** 更新全局的 RubyGems 1sudo gem update --system --no-user-install Ruby 的镜像存放在~/.gemrc里面 三、Ruby 的安装与切换 列出已知的 Ruby 版本 1rvm list known 查询已经安装的 Ruby 版本 1rvm list 切换 Ruby 版本 1rvm use 2.1.0 设置默认版本，控制台默认的 Ruby 版本 1rvm use 2.1.0 --default 卸载已安装的版本 1rvm remove 2.1.0]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView替换UIWebView]]></title>
    <url>%2F2016%2F07%2F01%2FWKWebView%E6%9B%BF%E6%8D%A2UIWebView%2F</url>
    <content type="text"><![CDATA[前言 目前,WKWebView只在iOS8后才能用,但是大多数App需要支持iOS7以上的版本，所以兼容性方案就是,iOS7下用UIWebView，iOS8后WKWebView. 一、介绍使用到的类 WKBackForwardList: 之前访问过的 web 页面的列表，可以通过后退和前进动作来访问到。 WKBackForwardListItem: WKWebView中后退列表里的某一个网页。 WKFrameInfo: 包含一个网页的布局信息。 WKNavigation: 包含一个网页的加载进度信息。 WKNavigationAction: 包含可能让网页导航变化的信息，用于判断是否做出导航变化。 WKNavigationResponse: 包含可能让网页导航变化的返回内容信息，用于判断是否做出导航变化。 WKPreferences: WKWebView的偏好设置。 WKProcessPool: WKWebView内容加载缓存池。 WKUserContentController: 提供使用 JavaScript post 信息和注射 script 的方法。 WKScriptMessage: 包含网页发出的信息。 WKUserScript: 网页接受的用户脚本。 WKWebViewConfiguration: 初始化WKWebView的设置。 WKWindowFeatures: 指定加载新网页时的窗口属性。 提供的协议 WKNavigationDelegate: 提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法。 WKUIDelegate: 提供用原生控件显示网页的方法回调。 WKScriptMessageHandler: 提供从网页中收消息的回调方法。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-iOS beta版本升级及回退.]]></title>
    <url>%2F2016%2F06%2F13%2FiOS-iOS%20beta%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%9B%9E%E9%80%80%2F</url>
    <content type="text"><![CDATA[前言: 笔者前段时间进行iOS 10测试版本升级,出现众多网友共性,程序崩溃、卡顿等问题影响使用.故想回退版本,但是看到许多需要抹掉数据才可恢复,偶遇一良方无需抹掉数据,并附上升级及回退版本教程以及回退版本固件下载地址一枚. iOS9.3.2升级iOS10 beta1一.下载官方描述文件-&gt;复制以下地址，使用自带Safari浏览器打开.iOS Beta Software Profile 描述文件下载地址: 二.安装描述文件,并重启设备. 三.重启后,进入设置-通用-软件更新,下载iOS 10 Developer Beta1安装程序,并安装. iOS10 beta1回退iOS9.3.2一.下载iOS9.3.2固件.ipsw格式.IPSW Downloads固件下载网站地址: 二.打开iTunes.按住Option(alt)键(Win系统按Shift)+点击检查更新. 三.选择下载好的固件进行回退. 四.点击更新后,提示验证固件,验证完成后点击完成.]]></content>
      <categories>
        <category>iPhone</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iPhone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费开发者证书真机调试App ID失效问题:"Unable to add App ID because the '10' App ID limit in '7' days has been exceeded."解决方案总结。]]></title>
    <url>%2F2016%2F04%2F29%2F%E5%85%8D%E8%B4%B9%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95App%20ID%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 今天(4月29日),笔者在做免费开发者证书真机调试的时候.发现如下问题: 问题:Unable to add App ID because the ‘10’ App ID limit in ‘7’ days has been exceeded.翻译如下: 寻求解决问题过程:第一次遇到,于是开始百度,发现百度没有这个问题.进行简要搜索时发现: 也是今天发布的寻找答案的,于是只能借助更强大的搜索: 在stack overflow中发现也有出现此问题: 链接如下:http://stackoverflow.com/questions/36923849/unable-to-add-app-id-because-the-10-app-id-limit-in-7-days-has-been-exceeded发现这个问题是4月28日晚上18点提交的,具体美国时间比中国晚一天,也就是说也是今天才发现的这个问题,看到解决方案.然后再开始跟苹果技术支持邮件联系得出如下答案:于是得出结论. 问题原因:这是苹果对Bundle Identifier进行了封锁. 推测:苹果于今天修改了规格,限制了开发者使用免证书的真机调试次数. 根据客服回电的答案得出,一个App ID,免证书真机调试只能进行10次,具体时间没有说明. 但是根据字面翻译意思在7天内只能创建10个项目文件(最主要的是Bundle Identifier名称),关于7天之外是否还能继续创建项目工程,笔者会持续更新. 5月5日测试,还是一直提示这个错误,持续猜想一个Apple ID,免证书真机调试只能进行10次. 5月10日测试,测试成功,7日内免证书真机调试10次可行. 5月12日测试,免证书真机调试生成描述文件后,View Details里面显示生成的Bundle Identifier更改成7天后过期,也就是说明一个Apple ID7天内可以只能生成10个Bundle Identifier. 这是苹果限制了Bundle Identifier的循环问题,减少了Bundle Identifier有效期时间,防止大量Bundle Identifier的堆积. 这样就可以及时去查看Bundle Identifier,等待Bundle Identifier到期后进行真机调试. 下图为显示Bundle Identifier的有效期(5月13日集中生成): 解决方案: 1.更换成开发者账号的App ID.(呵呵,你懂得.) 2.暂时解决方案,更换Bundle Identifier,把此前真机调试项目工程的Bundle Identifier更换成现在的项目工程的Bundle Identifier,(亲测可用!!) 3.重新创建项目工程的时候直接写成以前的真机测试通过的项目名字.(亲测可用!!) 解决方案会持续更新….. 友情提示:免费真机调试描述文件(.mobileprovision),有效期为90天,也就是说超过时间Bundle Identifier就不能用了.15月12日更新 .mobileprovision 有效期为更改7天. 解决办法:1.$99刀的开发者Apple ID.2.重新申请Apple ID,只申请1个描述文件(.mobileprovision),一直使用90天后再进行更换.(更换时间改为7天) 意外情况:一 . 更换Bundle Identifier还是没有解决: (亲测可用!!)当出现更换这里的Bundle Identifier还是没有用的时候 请更换项目工程里面的Bundle Identifier: 1.右键项目工程文件:显示包内容(Show Package Contents) 2.打开第一个文件: project.pbxproj 3.搜索: PRODUCT_BUNDLE_IDENTIFIER 进行替换4.发现有2个PRODUCT_BUNDLE_IDENTIFIER ,替换后面的 &gt;&gt;”.—-“&lt;&lt;,更换成以前自己可以真机调试Bundle Identifier这样也是可以的. 二 . 忘记之前创建的Bundle Identifier1.可以在偏好设置里面选择证书详情视图查找,Preferences-&gt;Accounts-&gt;View Details 2.根据排序,选择最近创建的Bundle Identifier]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac学习-系统Automator将显示与隐藏文件功能添加到Finder服务中.]]></title>
    <url>%2F2016%2F04%2F13%2FMac%E5%AD%A6%E4%B9%A0-%E7%B3%BB%E7%BB%9FAutomator%E5%B0%86%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%88%B0Finder%E6%9C%8D%E5%8A%A1%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[1 .启动Automator 2.选择新建文稿 3.选择服务 4.[1] 搜索 运行 -&gt; 选择 运行shell脚本 -&gt; [2] 设置 “服务”收到 没有输入和 位于Finder.app -&gt; [3] 添加如下命令12345678STATUS=`defaults read com.apple.finder AppleShowAllFiles`if [ $STATUS == YES ];then defaults write com.apple.finder AppleShowAllFiles NOelse defaults write com.apple.finder AppleShowAllFiles YESfikillall Finder 5.按 Commond + S 保存,并写入名字 6.在系统偏好设置中,选择键盘 7.设置键盘找到 显示与隐藏文件开关勾选 8.Finder 的菜单栏中选择 -&gt; 服务]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac搭建Hexo博客]]></title>
    <url>%2F2016%2F03%2F18%2FMac%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 终于把Hexo给弄好了.期间遇到了一些问题,网上也有教程,整理了一下思路决定再写一篇.最新官方的教程可以去Hexo官网查看. 一、准备安装XcodeXcode会一并安装git等依赖. 安装node.jsHexo是基于node.js的,要去官网上下载下来安装. 注册Github账户在本地搭建好Hexo后需要将内容同步到github上,才可以在网上浏览,可以去Github官网上去注册. 二、安装因为安装包中有些内容在墙外,所以可以换淘宝源,或者用 1npm install -g hexo-cli --no-optional cd进入你要安装的目录,如: hexo如果没有那就新建一个文件夹 1cd ~/hexo 然后初始化 1hexo init 初始化好之后,执行安装 1npm install 这样就已经安装完毕. 三、生成生成静态页面cd 到的目录,执行如下命令,生成静态页面至hexo\public\目录. 1hexo g (hexo generate简写) 本地启动执行好上面的命令之后,开始启动本地服务.再执行下面的命令： 1hexo server 看到 INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.之后,就可以在浏览器中打开页面http://localhost:4000来看了. 写文章还是在你cd到的目录,执行new命令后,生成指定名称的文章至hexo\source\ _posts\ blogName.md. 1hexo new &quot;blogName&quot; blogName就是文章名. 接下来,就可以用Markdown编辑器写你的文章了. 1234567格式:title: postName #文章页面上的显示名称,可以任意修改,不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间,一般不改,当然也可以任意修改categories: #文章分类目录,可以为空,注意:后面有个空格tags: #文章标签,可空,多标签请用格式[tag1,tag2,tag3],注意:后面有个空格---这里开始使用markdown格式输入你的正文. 四、上传至Github创建仓库并安装上传git插件在安装之前,首先我们要确认在你的Github帐号的Repository(仓库)中有 用户名.github.io 的项目.在确认之后,就可以执行命令 1npm install hexo-deployer-git --save 配置账号配置 _config.yml 文件在Hexo安装的目录,如 ~/Document/hexo 中找到 _config.yml 文件.打开.翻到最后,找到 deploy 字样,改成如下格式： 1234deploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: master 需要注意的是：冒号后面有一个空格；使用github可以不用写branch那一行.如果要使用多个 deployer,可改成如下样式： 12345deploy:- type: git repo:- type: hexoku repo: 同步1hexo d (hexo deploy简写) 执行,以后每次执行就可以依次输入下面三行命令： 123hexo cleanhexo g (hexo generate简写)hexo d (hexo deploy简写) 大功告成,可以输入你的用户名.github.io在浏览器中查看了. 五、插件搜索服务 本地搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 站点地图1npm install hexo-generator-sitemap --save 生成的sitemap.xml可以给搜索引擎收录使用.如果要生成百度的sitemap,使用以下命令： 1npm install hexo-generator-baidu-sitemap --save RSS订阅1npm install hexo-generator-feed@1.0.3 --save 六、主题更改Hexo提供了官网的主题, 初始化hexo时也会自动生成一个主题, Hexo还支持个性定制主题, 可以根据自己的喜好对主题进行修改, 更多主题可以在官网中找到 个性化博客的设置在博客的根目录下对喜爱的主题进行主题进行克隆 12345git clone git@github.com:yunlzheng/hexo-themes.git themes/writing#在./_config.yml,修改主题为writingtheme: writing#查看本地效果hexo g (hexo generate简写)hexo s (hexo server简写) 安装主题的方法就是一句git命令：1git clone https://github.com/xx/hexo-theme-xxxx.git themes/xxxx 目录是否是什么无所谓,只要与_config.yml文件一致即可. 安装完成后,打开hexo\_config.yml,修改主题为指定的主题名 1theme: xxxx 打开hexo\themes\xxxx目录,编辑主题配置文件_config.yml： 1234567891011121314151617181920212223242526272829menu: #配置页头显示哪些菜单# Home: / Archives: /archives Reading: /reading About: /about# Guestbook: /aboutexcerpt_link: Read More #摘要链接文字archive_yearly: false #按年存档widgets: #配置页脚显示哪些小挂件 - category# - tag - tagcloud - recent_posts# - blogrollblogrolls: #友情链接 - bruce sha&apos;s duapp wordpress: http://ibruce.duapp.com - bruce sha&apos;s javaeye: http://buru.iteye.com - bruce sha&apos;s oschina blog: http://my.oschina.net/buru - bruce sha&apos;s baidu space: http://hi.baidu.com/iburufancybox: true #是否开启fancybox效果duoshuo_shortname: buru #多说账号google_analytics:rss: 七、后续更新hexo1npm update -g hexo 更新主题12cd themes/modernistgit pull 更新插件：1npm update 遇到的问题12345678fatal: unable to access &apos;https://github.com/xxx/xxx.git/&apos;: Could not resolve host: github.comFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: unable to access &apos;https://github.com/xxx/xxx.git/&apos;: Could not resolve host: github.com at ChildProcess.&lt;anonymous&gt; (/Users/xxxx/hexo/node_modules/hexo-util/lib/spawn.js:37:17) at ChildProcess.emit (events.js:159:13) at maybeClose (internal/child_process.js:943:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:220:5) 解决方案: 在当前用户路径~输入 1ssh -v git@github.com 或者你的hexo路径输入 1ssh git@github.com 输入Github密码即可]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布博客]]></title>
    <url>%2F2016%2F03%2F08%2F%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[0.打开hexo地址1cd /Users/..../hexo 1.写博客1hexo new &quot;My New Post&quot; 更新信息: Writing 2.启动服务器1hexo server 更新信息: Server 3.生成静态文件1hexo generate 更新信息: Generating 4.同步1hexo deploy 更新信息: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux及Git命令总结。]]></title>
    <url>%2F2016%2F02%2F17%2FLinux%E5%8F%8AGit%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E3%80%82%2F</url>
    <content type="text"><![CDATA[常用Linux命令一、常用指令 显示文件或目录 1ls 列出文件详细信息列表(list) 1ls -l 列出当前目录下所有文件及目录，包括隐藏的文件(all) 1ls -a 创建目录 1mkdir 创建目录，若无父目录，则创建p(parent) 1mkdir -p 切换目录 1cd 创建空文件 1touch 创建带有内容的文件。 1echo 查看文件内容 1cat 拷贝 1cp 移动或重命名 1mv 删除文件 1rm 递归删除，可删除子目录及文件 1rm -r 强制删除 1rm -f 在文件系统中搜索某文件 1find 统计文本中行数、字数、字符数 1wc 在文本文件中查找某个字符串 1grep 删除空目录 1rmdir 树形结构显示目录，需要安装tree包 1tree 显示当前目录 1pwd 创建软链接 12 源文件 目标文件ln -s source dist 创建硬链接 12 源文件 目标文件ln source dist 检查磁盘空间 1df 检查磁盘空间(可读懂类型) 1df -h 检查磁盘空间(以M为计算单位) 1df -m 检查磁盘空间(以G为计算单位) 1df -g MacOS 磁盘管理命令 1diskutil 查询DNS解析 1dig 二、系统管理命令 查询进程 1top 杀死进程 1kill 1kill pid号 1kill -9 pid号 1kill -15 pid号 显示网络状态信息 1netstat 查看网络情况 1ifconfig 清屏 1clear 三、Vim编辑器 编辑文件 1vi 文件名 编辑 1i 取消编辑 1esc按键 退出 1:q 保存并退出 1:wq 显示行号 1:set number 隐藏行号 1:set nonumber 四、Ubuntu提示packages更新12sudo apt-get updatesudo apt-get dist-upgrade 常用Git命令一、新建代码库 在当前目录新建一个Git代码库 1git init 在当前目录新建并将其初始化为Git代码库 1git init &lt;project_name&gt; 克隆代码 1git clone &lt;url&gt; 二、配置Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置 1git config --list 编辑Git配置文件 1git config -e &lt;--global&gt; 三、增加/删除文件 添加指定文件到暂存区 1git add &lt;file1&gt; &lt;file2&gt; 添加指定目录到暂存区，包括子目录 1git add &lt;dir&gt; 添加当前目录的所有文件到暂存区 1git add . 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交 1git add -p 删除工作区文件，并且将这次删除放入暂存区 1git rm &lt;file1&gt; &lt;file2&gt; 停止追踪指定文件，但该文件会保留在工作区 1git rm --cached &lt;file&gt; 改名文件，并且将这个改名放入暂存区 1git mv &lt;file-original&gt; &lt;file-renamed&gt; 四、代码提交 提交暂存区到仓库区 1git commit -m &apos;message&apos; 提交暂存区的指定文件到仓库区 1git commit &lt;file1&gt; &lt;file2&gt; -m &apos;message&apos; 提交工作区自上次commit之后的变化，直接到仓库区 1git commit -a 提交时显示所有diff信息 1git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 1git commit --amend -m &apos;message&apos; 重做上一次commit，并包括指定文件的新变化 1git commit --amend &lt;file1&gt; &lt;file2&gt; 五、分支 列出所有本地分支 1git branch 列出所有远程分支 1git branch -r 列出所有本地分支和远程分支 1git branch -a 新建一个分支，但依然停留在当前分支 1git branch &lt;branch_name&gt; 新建一个分支，并切换到该分支 1git checkout -b &lt;branch_name&gt; 新建一个分支，指向指定commit 1git branch &lt;branch_name&gt; &lt;commit&gt; 新建一个分支，与指定的远程分支建立追踪关系 1git branch --track &lt;branch_name&gt; &lt;remote_branch&gt; 切换到指定分支或标签 1git checkout &lt;branch_name/tag&gt; 切换到上一个分支 1git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 1git branch --set-upstream &lt;branch_name&gt; &lt;remote_branch&gt; 合并指定分支到当前分支 1git merge &lt;branch_name&gt; 删除分支 1git branch -d &lt;branch_name&gt; 删除远程分支 1$ git push origin --delete &lt;branch_name&gt; 1$ git branch -dr &lt;remote/branch&gt; 六、标签 列出所有tag 1git tag 新建一个tag在当前commit 1git tag &lt;tag&gt; 新建一个tag在指定commit 1git tag &lt;tag&gt; &lt;commit&gt; 删除本地tag 1git tag -d &lt;tag&gt; 删除远程tag 1git push origin :refs/tags/&lt;tagName&gt; 查看tag信息 1git show &lt;tag&gt; 提交远程tag 1git push origin &lt;tag&gt; 提交到远程所有tag 1git push origin --tags 新建一个分支，指向某个tag 1git checkout -b &lt;branch&gt; &lt;tag&gt; 七、查看信息 显示有变更的文件 1git status 显示当前分支的版本历史 1git log 显示commit历史，以及每次commit发生变更的文件 1git log --stat 搜索提交历史，根据关键词 1git log -S &lt;keyword&gt; 显示某个commit之后的所有变动，每个commit占据一行 1git log &lt;tag&gt; HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 1git log &lt;tag&gt; HEAD --grep feature 显示某个文件的版本历史，包括文件改名 1git log --follow &lt;file&gt; 1git whatchanged &lt;file&gt; 显示指定文件相关的每一次diff 1git log -p &lt;file&gt; 显示过去5次提交 1git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序 1git shortlog -sn 显示指定文件是什么人在什么时间修改过 1git blame &lt;file&gt; 显示暂存区和工作区的差异 1git diff 显示暂存区和上一个commit的差异 1git diff --cached &lt;file&gt; 显示工作区与当前分支最新commit之间的差异 1git diff HEAD 显示两次提交之间的差异 1git diff &lt;first-branch&gt;...&lt;second-branch&gt; 显示今天你写了多少行代码 1git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 显示某次提交的元数据和内容变化 1git show &lt;commit&gt; 显示某次提交发生变化的文件 1git show --name-only &lt;commit&gt; 显示某次提交时，某个文件的内容 1git show &lt;commit&gt;:&lt;filename&gt; 显示当前分支的最近几次提交 1git reflog 八、远程同步 下载远程仓库的所有变动 1git fetch &lt;remote&gt; 显示所有远程仓库 1git remote -v 显示某个远程仓库的信息 1git remote show &lt;remote&gt; 增加一个新的远程仓库，并命名 1git remote add &lt;shortname&gt; &lt;url&gt; 取回远程仓库的变化，并与本地分支合并 1git pull &lt;remote&gt; &lt;branch&gt; 上传本地指定分支到远程仓库 1git push &lt;remote&gt; &lt;branch&gt; 强行推送当前分支到远程仓库，即使有冲突 123git push &lt;remote&gt; --force或者:git push -f -u origin master 推送所有分支到远程仓库 1git push &lt;remote&gt; --all 九、撤销 恢复暂存区的指定文件到工作区 1git checkout &lt;file&gt; 恢复某个commit的指定文件到暂存区和工作区 1git checkout &lt;commit&gt; &lt;file&gt; 恢复暂存区的所有文件到工作区 1git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 1git reset &lt;file&gt; 重置暂存区与工作区，与上一次commit保持一致 1git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 1git reset &lt;commit&gt; 重置当前分支回滚到某一次历史提交版本 ps: 回滚完在执行git push -f -u origin master 1git reset --hard &lt;commit&gt; 重置当前HEAD为指定commit，但保持暂存区和工作区不变 1git reset --keep &lt;commit&gt; 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 1git revert &lt;commit&gt; 暂时将未提交的变化移除，稍后再移入 1git stash 1git stash pop 十、其他 生成一个可供发布的压缩包 1git archive]]></content>
      <categories>
        <category>Linux</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Linux</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-资料整理]]></title>
    <url>%2F2015%2F12%2F17%2FSwift-%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[泛型参数泛型形参子句泛型形参子句指定泛型类型或函数的类型形参，以及这些参数的关联约束和关联类型要求（requirement）。泛型形参子句用尖括号（&lt;&gt;）包住，并且有以下两种形式： 12&lt;泛型形参列表&gt;&lt;泛型形参列表 where 关联类型要求&gt; 泛型形参列表中泛型形参用逗号分开，其中每一个采用以下形式： 1类型形参: 约束 泛型形参由两部分组成：类型形参及其后的可选约束。类型形参只是占位符类型（如 T，U，V，Key，Value 等）的名字而已。你可以在泛型类型、函数的其余部分或者初始化器声明，包括函数或初始化器的签名中使用它（与其任何相关类型）。 约束用于指明该类型形参继承自某个类或者遵守某个协议或协议的一部分。例如，在下面的泛型函数中，泛型形参T: Comparable表示任何用于替代类型形参T的类型实参必须满足Comparable协议。 123456func simpleMax&lt;T: Comparable&gt;(x: T, _ y: T) -&gt; T &#123; if x &lt; y &#123; return y &#125; return x&#125; 如，Int和Double均满足Comparable协议，该函数接受任何一种类型。与泛型类型相反，调用泛型函数或初始化器时不需要指定泛型实参子句。类型实参由传递给函数或初始化器的实参推断而出。 12simpleMax(17, 42) // T被推断出为Int类型simpleMax(3.14159, 2.71828) // T被推断出为Double类型 Where 子句要想对类型形参及其关联类型指定额外关联类型要求，可以在泛型形参列表之后添加where子句。where子句由关键字where及其后的用逗号分割的多个关联类型要求组成。where子句中的关联关系用于指明该类型形参继承自某个类或遵守某个协议或协议的一部分。尽管where子句提供了语法糖使其有助于表达类型形参上的简单约束（如T: Comparable等同于T where T: Comparable，等等），但是依然可以用来对类型形参及其关联类型提供更复杂的约束。如，&lt;T where T: C, T: P&gt;表示泛型类型T继承自类C且遵守协议P。 如上所述，可以强制约束类型形参的关联类型遵守某个协议。例如&lt;T: Generator where T.Element: Equatable&gt;表示T遵守Generator协议，而且T的关联类型T.Element遵守Eauatable协议（T有关联类型Element是因为Generator声明了Element，而T遵守Generator协议）。 也可以用操作符==来指定两个类型等效的关联关系。例如，有这样一个约束：T和U遵守Generator协议，同时要求它们的关联类型等同，可以这样来表达：&lt;T: Generator, U: Generator where T.Element == U.Element&gt;。 当然，替代类型形参的类型实参必须满足所有类型形参的约束和关联类型要求。 泛型函数或初始化器可以重载，但在泛型形参子句中的类型形参必须有不同的约束或关联类型要求，抑或二者皆不同。当调用重载的泛型函数或始化器时，编译器会用这些约束来决定调用哪个重载函数或始化器。 泛型形参子句语法 1234567891011泛型参数子句 → &lt; 泛型参数列表 约束子句 可选 &gt;泛型参数列表 → 泛形参数 | 泛形参数 , 泛型参数列表泛形参数 → 类型名称泛形参数 → 类型名称 : 类型标识泛形参数 → 类型名称 : 协议合成类型约束子句 → where 约束列表约束列表 → 约束 | 约束 , 约束列表约束 → 一致性约束 | 同类型约束一致性约束 → 类型标识 : 类型标识一致性约束 → 类型标识 : 协议合成类型同类型约束 → 类型标识 == 类型标识 泛型实参子句泛型实参子句指定泛型类型的类型实参。泛型实参子句用尖括号（&lt;&gt;）包住，形式如下： 1&lt;泛型实参列表&gt; 泛型实参列表中类型实参有逗号分开。类型实参是实际具体类型的名字，用来替代泛型类型的泛型形参子句中的相应的类型形参。从而得到泛型类型的一个特化版本。如，Swift标准库的泛型字典类型定义如下： 123struct Dictionary&lt;KeyTypel: Hashable, ValueType&gt;: Collection, DictionaryLiteralConvertible &#123; /* .. */&#125; 泛型Dictionary类型的特化版本，Dictionary&lt;String, Int&gt;就是用具体的String和Int类型替代泛型类型KeyType: Hashable和ValueType产生的。每一个类型实参必须满足它所替代的泛型形参的所有约束，包括任何where子句所指定的额外的关联类型要求。上面的例子中，类型形参Key类型要求满足Hashable协议，因此String也必须满足Hashable协议。可以用本身就是泛型类型的特化版本的类型实参替代类型形参（假设已满足合适的约束和关联类型要求）。例如，为了生成一个元素类型是整型数组的数组，可以用数组的特化版本Array&lt;Int&gt;替代泛型类型Array&lt;T&gt;的类型形参 T 来实现。 let arrayOfArrays: Array&lt;Array&lt;Int&gt;&gt; = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 如泛型形参子句所述，不能用泛型实参子句来指定泛型函数或初始化器的类型实参。 泛型实参子句语法 123(泛型参数子句Generic Argument Clause) → &lt; 泛型参数列表 &gt;泛型参数列表 → 泛型参数 | 泛型参数 , 泛型参数列表泛型参数 → 类型]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
